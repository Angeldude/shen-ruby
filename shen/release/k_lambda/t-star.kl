"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2753 V2754) (let Curry (shen.curry V2753) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.normalise-type (shen.curry-type V2754)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2755) (cond ((and (cons? V2755) (shen.special? (hd V2755))) (cons (hd V2755) (map shen.curry (tl V2755)))) ((and (cons? V2755) (and (cons? (tl V2755)) (shen.extraspecial? (hd V2755)))) V2755) ((and (cons? V2755) (and (cons? (tl V2755)) (cons? (tl (tl V2755))))) (shen.curry (cons (cons (hd V2755) (cons (hd (tl V2755)) ())) (tl (tl V2755))))) ((and (cons? V2755) (and (cons? (tl V2755)) (= () (tl (tl V2755))))) (cons (shen.curry (hd V2755)) (cons (shen.curry (hd (tl V2755))) ()))) (true V2755)))

(defun shen.special? (V2756) (element? V2756 (value shen.*special*)))

(defun shen.extraspecial? (V2757) (element? V2757 (value shen.*extraspecial*)))

(defun shen.t* (V2758 V2759 V2760 V2761) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2760) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2760 (freeze (bind Error (shen.errormaxinfs) V2760 V2761))))) (if (= Case false) (let Case (let V2747 (shen.lazyderef V2758 V2760) (if (= fail V2747) (do (shen.incinfs) (cut Throwcontrol V2760 (freeze (shen.prolog-failure V2760 V2761)))) false)) (if (= Case false) (let Case (let V2748 (shen.lazyderef V2758 V2760) (if (cons? V2748) (let X (hd V2748) (let V2749 (shen.lazyderef (tl V2748) V2760) (if (cons? V2749) (let V2750 (shen.lazyderef (hd V2749) V2760) (if (= : V2750) (let V2751 (shen.lazyderef (tl V2749) V2760) (if (cons? V2751) (let A (hd V2751) (let V2752 (shen.lazyderef (tl V2751) V2760) (if (= () V2752) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2760 (freeze (cut Throwcontrol V2760 (freeze (shen.th* X A V2759 V2760 V2761)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2760) (do (shen.incinfs) (shen.show V2758 V2759 V2760 (freeze (bind Datatypes (value shen.*datatypes*) V2760 (freeze (shen.udefs* V2758 V2759 Datatypes V2760 V2761))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2766) (cond ((= + V2766) (set shen.*shen-type-theory-enabled?* true)) ((= - V2766) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2775 V2776) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2777 V2778 V2779 V2780 V2781) (let Case (let V2743 (shen.lazyderef V2779 V2780) (if (cons? V2743) (let D (hd V2743) (do (shen.incinfs) (call (cons D (cons V2777 (cons V2778 ()))) V2780 V2781))) false)) (if (= Case false) (let V2744 (shen.lazyderef V2779 V2780) (if (cons? V2744) (let Ds (tl V2744) (do (shen.incinfs) (shen.udefs* V2777 V2778 Ds V2780 V2781))) false)) Case)))

(defun shen.th* (V2782 V2783 V2784 V2785 V2786) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2782 (cons : (cons V2783 ()))) V2784 V2785 (freeze (fwhen false V2785 V2786)))) (if (= Case false) (let Case (let F (shen.newpv V2785) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2782 V2785)) V2785 (freeze (bind F (shen.sigf (shen.lazyderef V2782 V2785)) V2785 (freeze (call (cons F (cons V2783 ())) V2785 V2786))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2782 V2783 V2785 V2786)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2782 V2783 V2784 V2785 V2786)) (if (= Case false) (let Case (let V2623 (shen.lazyderef V2782 V2785) (if (cons? V2623) (let F (hd V2623) (let V2624 (shen.lazyderef (tl V2623) V2785) (if (= () V2624) (do (shen.incinfs) (shen.th* F (cons --> (cons V2783 ())) V2784 V2785 V2786)) false))) false)) (if (= Case false) (let Case (let V2625 (shen.lazyderef V2782 V2785) (if (cons? V2625) (let F (hd V2625) (let V2626 (shen.lazyderef (tl V2625) V2785) (if (cons? V2626) (let X (hd V2626) (let V2627 (shen.lazyderef (tl V2626) V2785) (if (= () V2627) (let B (shen.newpv V2785) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2783 ()))) V2784 V2785 (freeze (shen.th* X B V2784 V2785 V2786))))) false))) false))) false)) (if (= Case false) (let Case (let V2628 (shen.lazyderef V2782 V2785) (if (cons? V2628) (let V2629 (shen.lazyderef (hd V2628) V2785) (if (= cons V2629) (let V2630 (shen.lazyderef (tl V2628) V2785) (if (cons? V2630) (let X (hd V2630) (let V2631 (shen.lazyderef (tl V2630) V2785) (if (cons? V2631) (let Y (hd V2631) (let V2632 (shen.lazyderef (tl V2631) V2785) (if (= () V2632) (let V2633 (shen.lazyderef V2783 V2785) (if (cons? V2633) (let V2634 (shen.lazyderef (hd V2633) V2785) (if (= list V2634) (let V2635 (shen.lazyderef (tl V2633) V2785) (if (cons? V2635) (let A (hd V2635) (let V2636 (shen.lazyderef (tl V2635) V2785) (if (= () V2636) (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons list (cons A ())) V2784 V2785 V2786)))) (if (shen.pvar? V2636) (do (shen.bindv V2636 () V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons list (cons A ())) V2784 V2785 V2786)))) (do (shen.unbindv V2636 V2785) Result))) false)))) (if (shen.pvar? V2635) (let A (shen.newpv V2785) (do (shen.bindv V2635 (cons A ()) V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons list (cons A ())) V2784 V2785 V2786)))) (do (shen.unbindv V2635 V2785) Result)))) false))) (if (shen.pvar? V2634) (do (shen.bindv V2634 list V2785) (let Result (let V2637 (shen.lazyderef (tl V2633) V2785) (if (cons? V2637) (let A (hd V2637) (let V2638 (shen.lazyderef (tl V2637) V2785) (if (= () V2638) (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons list (cons A ())) V2784 V2785 V2786)))) (if (shen.pvar? V2638) (do (shen.bindv V2638 () V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons list (cons A ())) V2784 V2785 V2786)))) (do (shen.unbindv V2638 V2785) Result))) false)))) (if (shen.pvar? V2637) (let A (shen.newpv V2785) (do (shen.bindv V2637 (cons A ()) V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons list (cons A ())) V2784 V2785 V2786)))) (do (shen.unbindv V2637 V2785) Result)))) false))) (do (shen.unbindv V2634 V2785) Result))) false))) (if (shen.pvar? V2633) (let A (shen.newpv V2785) (do (shen.bindv V2633 (cons list (cons A ())) V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons list (cons A ())) V2784 V2785 V2786)))) (do (shen.unbindv V2633 V2785) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2639 (shen.lazyderef V2782 V2785) (if (cons? V2639) (let V2640 (shen.lazyderef (hd V2639) V2785) (if (= @p V2640) (let V2641 (shen.lazyderef (tl V2639) V2785) (if (cons? V2641) (let X (hd V2641) (let V2642 (shen.lazyderef (tl V2641) V2785) (if (cons? V2642) (let Y (hd V2642) (let V2643 (shen.lazyderef (tl V2642) V2785) (if (= () V2643) (let V2644 (shen.lazyderef V2783 V2785) (if (cons? V2644) (let A (hd V2644) (let V2645 (shen.lazyderef (tl V2644) V2785) (if (cons? V2645) (let V2646 (shen.lazyderef (hd V2645) V2785) (if (= * V2646) (let V2647 (shen.lazyderef (tl V2645) V2785) (if (cons? V2647) (let B (hd V2647) (let V2648 (shen.lazyderef (tl V2647) V2785) (if (= () V2648) (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y B V2784 V2785 V2786)))) (if (shen.pvar? V2648) (do (shen.bindv V2648 () V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y B V2784 V2785 V2786)))) (do (shen.unbindv V2648 V2785) Result))) false)))) (if (shen.pvar? V2647) (let B (shen.newpv V2785) (do (shen.bindv V2647 (cons B ()) V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y B V2784 V2785 V2786)))) (do (shen.unbindv V2647 V2785) Result)))) false))) (if (shen.pvar? V2646) (do (shen.bindv V2646 * V2785) (let Result (let V2649 (shen.lazyderef (tl V2645) V2785) (if (cons? V2649) (let B (hd V2649) (let V2650 (shen.lazyderef (tl V2649) V2785) (if (= () V2650) (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y B V2784 V2785 V2786)))) (if (shen.pvar? V2650) (do (shen.bindv V2650 () V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y B V2784 V2785 V2786)))) (do (shen.unbindv V2650 V2785) Result))) false)))) (if (shen.pvar? V2649) (let B (shen.newpv V2785) (do (shen.bindv V2649 (cons B ()) V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y B V2784 V2785 V2786)))) (do (shen.unbindv V2649 V2785) Result)))) false))) (do (shen.unbindv V2646 V2785) Result))) false))) (if (shen.pvar? V2645) (let B (shen.newpv V2785) (do (shen.bindv V2645 (cons * (cons B ())) V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y B V2784 V2785 V2786)))) (do (shen.unbindv V2645 V2785) Result)))) false)))) (if (shen.pvar? V2644) (let A (shen.newpv V2785) (let B (shen.newpv V2785) (do (shen.bindv V2644 (cons A (cons * (cons B ()))) V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y B V2784 V2785 V2786)))) (do (shen.unbindv V2644 V2785) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2651 (shen.lazyderef V2782 V2785) (if (cons? V2651) (let V2652 (shen.lazyderef (hd V2651) V2785) (if (= @v V2652) (let V2653 (shen.lazyderef (tl V2651) V2785) (if (cons? V2653) (let X (hd V2653) (let V2654 (shen.lazyderef (tl V2653) V2785) (if (cons? V2654) (let Y (hd V2654) (let V2655 (shen.lazyderef (tl V2654) V2785) (if (= () V2655) (let V2656 (shen.lazyderef V2783 V2785) (if (cons? V2656) (let V2657 (shen.lazyderef (hd V2656) V2785) (if (= vector V2657) (let V2658 (shen.lazyderef (tl V2656) V2785) (if (cons? V2658) (let A (hd V2658) (let V2659 (shen.lazyderef (tl V2658) V2785) (if (= () V2659) (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons vector (cons A ())) V2784 V2785 V2786)))) (if (shen.pvar? V2659) (do (shen.bindv V2659 () V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons vector (cons A ())) V2784 V2785 V2786)))) (do (shen.unbindv V2659 V2785) Result))) false)))) (if (shen.pvar? V2658) (let A (shen.newpv V2785) (do (shen.bindv V2658 (cons A ()) V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons vector (cons A ())) V2784 V2785 V2786)))) (do (shen.unbindv V2658 V2785) Result)))) false))) (if (shen.pvar? V2657) (do (shen.bindv V2657 vector V2785) (let Result (let V2660 (shen.lazyderef (tl V2656) V2785) (if (cons? V2660) (let A (hd V2660) (let V2661 (shen.lazyderef (tl V2660) V2785) (if (= () V2661) (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons vector (cons A ())) V2784 V2785 V2786)))) (if (shen.pvar? V2661) (do (shen.bindv V2661 () V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons vector (cons A ())) V2784 V2785 V2786)))) (do (shen.unbindv V2661 V2785) Result))) false)))) (if (shen.pvar? V2660) (let A (shen.newpv V2785) (do (shen.bindv V2660 (cons A ()) V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons vector (cons A ())) V2784 V2785 V2786)))) (do (shen.unbindv V2660 V2785) Result)))) false))) (do (shen.unbindv V2657 V2785) Result))) false))) (if (shen.pvar? V2656) (let A (shen.newpv V2785) (do (shen.bindv V2656 (cons vector (cons A ())) V2785) (let Result (do (shen.incinfs) (shen.th* X A V2784 V2785 (freeze (shen.th* Y (cons vector (cons A ())) V2784 V2785 V2786)))) (do (shen.unbindv V2656 V2785) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2662 (shen.lazyderef V2782 V2785) (if (cons? V2662) (let V2663 (shen.lazyderef (hd V2662) V2785) (if (= @s V2663) (let V2664 (shen.lazyderef (tl V2662) V2785) (if (cons? V2664) (let X (hd V2664) (let V2665 (shen.lazyderef (tl V2664) V2785) (if (cons? V2665) (let Y (hd V2665) (let V2666 (shen.lazyderef (tl V2665) V2785) (if (= () V2666) (let V2667 (shen.lazyderef V2783 V2785) (if (= string V2667) (do (shen.incinfs) (shen.th* X string V2784 V2785 (freeze (shen.th* Y string V2784 V2785 V2786)))) (if (shen.pvar? V2667) (do (shen.bindv V2667 string V2785) (let Result (do (shen.incinfs) (shen.th* X string V2784 V2785 (freeze (shen.th* Y string V2784 V2785 V2786)))) (do (shen.unbindv V2667 V2785) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2668 (shen.lazyderef V2782 V2785) (if (cons? V2668) (let V2669 (shen.lazyderef (hd V2668) V2785) (if (= lambda V2669) (let V2670 (shen.lazyderef (tl V2668) V2785) (if (cons? V2670) (let X (hd V2670) (let V2671 (shen.lazyderef (tl V2670) V2785) (if (cons? V2671) (let Y (hd V2671) (let V2672 (shen.lazyderef (tl V2671) V2785) (if (= () V2672) (let V2673 (shen.lazyderef V2783 V2785) (if (cons? V2673) (let A (hd V2673) (let V2674 (shen.lazyderef (tl V2673) V2785) (if (cons? V2674) (let V2675 (shen.lazyderef (hd V2674) V2785) (if (= --> V2675) (let V2676 (shen.lazyderef (tl V2674) V2785) (if (cons? V2676) (let B (hd V2676) (let V2677 (shen.lazyderef (tl V2676) V2785) (if (= () V2677) (let Z (shen.newpv V2785) (let X&& (shen.newpv V2785) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (bind X&& (shen.placeholder) V2785 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2785) (shen.lazyderef X V2785) (shen.lazyderef Y V2785)) V2785 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2784) V2785 V2786)))))))))) (if (shen.pvar? V2677) (do (shen.bindv V2677 () V2785) (let Result (let Z (shen.newpv V2785) (let X&& (shen.newpv V2785) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (bind X&& (shen.placeholder) V2785 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2785) (shen.lazyderef X V2785) (shen.lazyderef Y V2785)) V2785 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2784) V2785 V2786)))))))))) (do (shen.unbindv V2677 V2785) Result))) false)))) (if (shen.pvar? V2676) (let B (shen.newpv V2785) (do (shen.bindv V2676 (cons B ()) V2785) (let Result (let Z (shen.newpv V2785) (let X&& (shen.newpv V2785) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (bind X&& (shen.placeholder) V2785 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2785) (shen.lazyderef X V2785) (shen.lazyderef Y V2785)) V2785 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2784) V2785 V2786)))))))))) (do (shen.unbindv V2676 V2785) Result)))) false))) (if (shen.pvar? V2675) (do (shen.bindv V2675 --> V2785) (let Result (let V2678 (shen.lazyderef (tl V2674) V2785) (if (cons? V2678) (let B (hd V2678) (let V2679 (shen.lazyderef (tl V2678) V2785) (if (= () V2679) (let Z (shen.newpv V2785) (let X&& (shen.newpv V2785) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (bind X&& (shen.placeholder) V2785 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2785) (shen.lazyderef X V2785) (shen.lazyderef Y V2785)) V2785 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2784) V2785 V2786)))))))))) (if (shen.pvar? V2679) (do (shen.bindv V2679 () V2785) (let Result (let Z (shen.newpv V2785) (let X&& (shen.newpv V2785) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (bind X&& (shen.placeholder) V2785 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2785) (shen.lazyderef X V2785) (shen.lazyderef Y V2785)) V2785 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2784) V2785 V2786)))))))))) (do (shen.unbindv V2679 V2785) Result))) false)))) (if (shen.pvar? V2678) (let B (shen.newpv V2785) (do (shen.bindv V2678 (cons B ()) V2785) (let Result (let Z (shen.newpv V2785) (let X&& (shen.newpv V2785) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (bind X&& (shen.placeholder) V2785 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2785) (shen.lazyderef X V2785) (shen.lazyderef Y V2785)) V2785 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2784) V2785 V2786)))))))))) (do (shen.unbindv V2678 V2785) Result)))) false))) (do (shen.unbindv V2675 V2785) Result))) false))) (if (shen.pvar? V2674) (let B (shen.newpv V2785) (do (shen.bindv V2674 (cons --> (cons B ())) V2785) (let Result (let Z (shen.newpv V2785) (let X&& (shen.newpv V2785) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (bind X&& (shen.placeholder) V2785 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2785) (shen.lazyderef X V2785) (shen.lazyderef Y V2785)) V2785 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2784) V2785 V2786)))))))))) (do (shen.unbindv V2674 V2785) Result)))) false)))) (if (shen.pvar? V2673) (let A (shen.newpv V2785) (let B (shen.newpv V2785) (do (shen.bindv V2673 (cons A (cons --> (cons B ()))) V2785) (let Result (let Z (shen.newpv V2785) (let X&& (shen.newpv V2785) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (bind X&& (shen.placeholder) V2785 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2785) (shen.lazyderef X V2785) (shen.lazyderef Y V2785)) V2785 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2784) V2785 V2786)))))))))) (do (shen.unbindv V2673 V2785) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2680 (shen.lazyderef V2782 V2785) (if (cons? V2680) (let V2681 (shen.lazyderef (hd V2680) V2785) (if (= let V2681) (let V2682 (shen.lazyderef (tl V2680) V2785) (if (cons? V2682) (let X (hd V2682) (let V2683 (shen.lazyderef (tl V2682) V2785) (if (cons? V2683) (let Y (hd V2683) (let V2684 (shen.lazyderef (tl V2683) V2785) (if (cons? V2684) (let Z (hd V2684) (let V2685 (shen.lazyderef (tl V2684) V2785) (if (= () V2685) (let W (shen.newpv V2785) (let X&& (shen.newpv V2785) (let B (shen.newpv V2785) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (shen.th* Y B V2784 V2785 (freeze (bind X&& (shen.placeholder) V2785 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2785) (shen.lazyderef X V2785) (shen.lazyderef Z V2785)) V2785 (freeze (shen.th* W V2783 (cons (cons X&& (cons : (cons B ()))) V2784) V2785 V2786))))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2686 (shen.lazyderef V2782 V2785) (if (cons? V2686) (let V2687 (shen.lazyderef (hd V2686) V2785) (if (= open V2687) (let V2688 (shen.lazyderef (tl V2686) V2785) (if (cons? V2688) (let V2689 (shen.lazyderef (hd V2688) V2785) (if (= file V2689) (let V2690 (shen.lazyderef (tl V2688) V2785) (if (cons? V2690) (let FileName (hd V2690) (let V2691 (shen.lazyderef (tl V2690) V2785) (if (cons? V2691) (let Direction2619 (hd V2691) (let V2692 (shen.lazyderef (tl V2691) V2785) (if (= () V2692) (let V2693 (shen.lazyderef V2783 V2785) (if (cons? V2693) (let V2694 (shen.lazyderef (hd V2693) V2785) (if (= stream V2694) (let V2695 (shen.lazyderef (tl V2693) V2785) (if (cons? V2695) (let Direction (hd V2695) (let V2696 (shen.lazyderef (tl V2695) V2785) (if (= () V2696) (do (shen.incinfs) (unify! Direction Direction2619 V2785 (freeze (cut Throwcontrol V2785 (freeze (shen.th* FileName string V2784 V2785 V2786)))))) (if (shen.pvar? V2696) (do (shen.bindv V2696 () V2785) (let Result (do (shen.incinfs) (unify! Direction Direction2619 V2785 (freeze (cut Throwcontrol V2785 (freeze (shen.th* FileName string V2784 V2785 V2786)))))) (do (shen.unbindv V2696 V2785) Result))) false)))) (if (shen.pvar? V2695) (let Direction (shen.newpv V2785) (do (shen.bindv V2695 (cons Direction ()) V2785) (let Result (do (shen.incinfs) (unify! Direction Direction2619 V2785 (freeze (cut Throwcontrol V2785 (freeze (shen.th* FileName string V2784 V2785 V2786)))))) (do (shen.unbindv V2695 V2785) Result)))) false))) (if (shen.pvar? V2694) (do (shen.bindv V2694 stream V2785) (let Result (let V2697 (shen.lazyderef (tl V2693) V2785) (if (cons? V2697) (let Direction (hd V2697) (let V2698 (shen.lazyderef (tl V2697) V2785) (if (= () V2698) (do (shen.incinfs) (unify! Direction Direction2619 V2785 (freeze (cut Throwcontrol V2785 (freeze (shen.th* FileName string V2784 V2785 V2786)))))) (if (shen.pvar? V2698) (do (shen.bindv V2698 () V2785) (let Result (do (shen.incinfs) (unify! Direction Direction2619 V2785 (freeze (cut Throwcontrol V2785 (freeze (shen.th* FileName string V2784 V2785 V2786)))))) (do (shen.unbindv V2698 V2785) Result))) false)))) (if (shen.pvar? V2697) (let Direction (shen.newpv V2785) (do (shen.bindv V2697 (cons Direction ()) V2785) (let Result (do (shen.incinfs) (unify! Direction Direction2619 V2785 (freeze (cut Throwcontrol V2785 (freeze (shen.th* FileName string V2784 V2785 V2786)))))) (do (shen.unbindv V2697 V2785) Result)))) false))) (do (shen.unbindv V2694 V2785) Result))) false))) (if (shen.pvar? V2693) (let Direction (shen.newpv V2785) (do (shen.bindv V2693 (cons stream (cons Direction ())) V2785) (let Result (do (shen.incinfs) (unify! Direction Direction2619 V2785 (freeze (cut Throwcontrol V2785 (freeze (shen.th* FileName string V2784 V2785 V2786)))))) (do (shen.unbindv V2693 V2785) Result)))) false))) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2699 (shen.lazyderef V2782 V2785) (if (cons? V2699) (let V2700 (shen.lazyderef (hd V2699) V2785) (if (= type V2700) (let V2701 (shen.lazyderef (tl V2699) V2785) (if (cons? V2701) (let X (hd V2701) (let V2702 (shen.lazyderef (tl V2701) V2785) (if (cons? V2702) (let A (hd V2702) (let V2703 (shen.lazyderef (tl V2702) V2785) (if (= () V2703) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (unify A V2783 V2785 (freeze (shen.th* X A V2784 V2785 V2786)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2704 (shen.lazyderef V2782 V2785) (if (cons? V2704) (let V2705 (shen.lazyderef (hd V2704) V2785) (if (= input+ V2705) (let V2706 (shen.lazyderef (tl V2704) V2785) (if (cons? V2706) (let V2707 (shen.lazyderef (hd V2706) V2785) (if (= : V2707) (let V2708 (shen.lazyderef (tl V2706) V2785) (if (cons? V2708) (let A (hd V2708) (let V2709 (shen.lazyderef (tl V2708) V2785) (if (= () V2709) (let C (shen.newpv V2785) (do (shen.incinfs) (bind C (shen.normalise-type (shen.lazyderef A V2785)) V2785 (freeze (unify V2783 C V2785 V2786))))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2710 (shen.lazyderef V2782 V2785) (if (cons? V2710) (let V2711 (shen.lazyderef (hd V2710) V2785) (if (= where V2711) (let V2712 (shen.lazyderef (tl V2710) V2785) (if (cons? V2712) (let P (hd V2712) (let V2713 (shen.lazyderef (tl V2712) V2785) (if (cons? V2713) (let X (hd V2713) (let V2714 (shen.lazyderef (tl V2713) V2785) (if (= () V2714) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (shen.th* P boolean V2784 V2785 (freeze (cut Throwcontrol V2785 (freeze (shen.th* X V2783 (cons (cons P (cons : (cons verified ()))) V2784) V2785 V2786)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2715 (shen.lazyderef V2782 V2785) (if (cons? V2715) (let V2716 (shen.lazyderef (hd V2715) V2785) (if (= set V2716) (let V2717 (shen.lazyderef (tl V2715) V2785) (if (cons? V2717) (let Var (hd V2717) (let V2718 (shen.lazyderef (tl V2717) V2785) (if (cons? V2718) (let Val (hd V2718) (let V2719 (shen.lazyderef (tl V2718) V2785) (if (= () V2719) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (shen.th* (cons value (cons Var ())) V2783 V2784 V2785 (freeze (shen.th* Val V2783 V2784 V2785 V2786)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2720 (shen.lazyderef V2782 V2785) (if (cons? V2720) (let V2721 (shen.lazyderef (hd V2720) V2785) (if (= shen.<-sem V2721) (let V2722 (shen.lazyderef (tl V2720) V2785) (if (cons? V2722) (let F (hd V2722) (let V2723 (shen.lazyderef (tl V2722) V2785) (if (= () V2723) (let A (shen.newpv V2785) (let F&& (shen.newpv V2785) (let B (shen.newpv V2785) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (shen.th* F (cons A (cons ==> (cons B ()))) V2784 V2785 (freeze (cut Throwcontrol V2785 (freeze (bind F&& (concat && (shen.lazyderef F V2785)) V2785 (freeze (cut Throwcontrol V2785 (freeze (shen.th* F&& V2783 (cons (cons F&& (cons : (cons B ()))) V2784) V2785 V2786))))))))))))))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2724 (shen.lazyderef V2782 V2785) (if (cons? V2724) (let V2725 (shen.lazyderef (hd V2724) V2785) (if (= fail V2725) (let V2726 (shen.lazyderef (tl V2724) V2785) (if (= () V2726) (let V2727 (shen.lazyderef V2783 V2785) (if (= symbol V2727) (do (shen.incinfs) (thaw V2786)) (if (shen.pvar? V2727) (do (shen.bindv V2727 symbol V2785) (let Result (do (shen.incinfs) (thaw V2786)) (do (shen.unbindv V2727 V2785) Result))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2785) (do (shen.incinfs) (shen.t*-hyps V2784 NewHyp V2785 (freeze (shen.th* V2782 V2783 NewHyp V2785 V2786))))) (if (= Case false) (let Case (let V2728 (shen.lazyderef V2782 V2785) (if (cons? V2728) (let V2729 (shen.lazyderef (hd V2728) V2785) (if (= define V2729) (let V2730 (shen.lazyderef (tl V2728) V2785) (if (cons? V2730) (let F (hd V2730) (let X (tl V2730) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (shen.t*-def (cons define (cons F X)) V2783 V2784 V2785 V2786)))))) false)) false)) false)) (if (= Case false) (let Case (let V2731 (shen.lazyderef V2782 V2785) (if (cons? V2731) (let V2732 (shen.lazyderef (hd V2731) V2785) (if (= defcc V2732) (let V2733 (shen.lazyderef (tl V2731) V2785) (if (cons? V2733) (let F (hd V2733) (let X (tl V2733) (do (shen.incinfs) (cut Throwcontrol V2785 (freeze (shen.t*-defcc (cons defcc (cons F X)) V2783 V2784 V2785 V2786)))))) false)) false)) false)) (if (= Case false) (let Case (let V2734 (shen.lazyderef V2782 V2785) (if (cons? V2734) (let V2735 (shen.lazyderef (hd V2734) V2785) (if (= shen.process-datatype V2735) (let V2736 (shen.lazyderef V2783 V2785) (if (= symbol V2736) (do (shen.incinfs) (thaw V2786)) (if (shen.pvar? V2736) (do (shen.bindv V2736 symbol V2785) (let Result (do (shen.incinfs) (thaw V2786)) (do (shen.unbindv V2736 V2785) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2737 (shen.lazyderef V2782 V2785) (if (cons? V2737) (let V2738 (shen.lazyderef (hd V2737) V2785) (if (= shen.synonyms-help V2738) (let V2739 (shen.lazyderef V2783 V2785) (if (= symbol V2739) (do (shen.incinfs) (thaw V2786)) (if (shen.pvar? V2739) (do (shen.bindv V2739 symbol V2785) (let Result (do (shen.incinfs) (thaw V2786)) (do (shen.unbindv V2739 V2785) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2785) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2785 (freeze (shen.udefs* (cons V2782 (cons : (cons V2783 ()))) V2784 Datatypes V2785 V2786))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2787 V2788 V2789 V2790) (let Case (let V2534 (shen.lazyderef V2787 V2789) (if (cons? V2534) (let V2535 (shen.lazyderef (hd V2534) V2789) (if (cons? V2535) (let V2536 (shen.lazyderef (hd V2535) V2789) (if (cons? V2536) (let V2537 (shen.lazyderef (hd V2536) V2789) (if (= cons V2537) (let V2538 (shen.lazyderef (tl V2536) V2789) (if (cons? V2538) (let X (hd V2538) (let V2539 (shen.lazyderef (tl V2538) V2789) (if (cons? V2539) (let Y (hd V2539) (let V2540 (shen.lazyderef (tl V2539) V2789) (if (= () V2540) (let V2541 (shen.lazyderef (tl V2535) V2789) (if (cons? V2541) (let V2542 (shen.lazyderef (hd V2541) V2789) (if (= : V2542) (let V2543 (shen.lazyderef (tl V2541) V2789) (if (cons? V2543) (let V2544 (shen.lazyderef (hd V2543) V2789) (if (cons? V2544) (let V2545 (shen.lazyderef (hd V2544) V2789) (if (= list V2545) (let V2546 (shen.lazyderef (tl V2544) V2789) (if (cons? V2546) (let A (hd V2546) (let V2547 (shen.lazyderef (tl V2546) V2789) (if (= () V2547) (let V2548 (shen.lazyderef (tl V2543) V2789) (if (= () V2548) (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2548) (do (shen.bindv V2548 () V2789) (let Result (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2548 V2789) Result))) false))) (if (shen.pvar? V2547) (do (shen.bindv V2547 () V2789) (let Result (let V2549 (shen.lazyderef (tl V2543) V2789) (if (= () V2549) (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2549) (do (shen.bindv V2549 () V2789) (let Result (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2549 V2789) Result))) false))) (do (shen.unbindv V2547 V2789) Result))) false)))) (if (shen.pvar? V2546) (let A (shen.newpv V2789) (do (shen.bindv V2546 (cons A ()) V2789) (let Result (let V2550 (shen.lazyderef (tl V2543) V2789) (if (= () V2550) (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2550) (do (shen.bindv V2550 () V2789) (let Result (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2550 V2789) Result))) false))) (do (shen.unbindv V2546 V2789) Result)))) false))) (if (shen.pvar? V2545) (do (shen.bindv V2545 list V2789) (let Result (let V2551 (shen.lazyderef (tl V2544) V2789) (if (cons? V2551) (let A (hd V2551) (let V2552 (shen.lazyderef (tl V2551) V2789) (if (= () V2552) (let V2553 (shen.lazyderef (tl V2543) V2789) (if (= () V2553) (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2553) (do (shen.bindv V2553 () V2789) (let Result (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2553 V2789) Result))) false))) (if (shen.pvar? V2552) (do (shen.bindv V2552 () V2789) (let Result (let V2554 (shen.lazyderef (tl V2543) V2789) (if (= () V2554) (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2554) (do (shen.bindv V2554 () V2789) (let Result (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2554 V2789) Result))) false))) (do (shen.unbindv V2552 V2789) Result))) false)))) (if (shen.pvar? V2551) (let A (shen.newpv V2789) (do (shen.bindv V2551 (cons A ()) V2789) (let Result (let V2555 (shen.lazyderef (tl V2543) V2789) (if (= () V2555) (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2555) (do (shen.bindv V2555 () V2789) (let Result (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2555 V2789) Result))) false))) (do (shen.unbindv V2551 V2789) Result)))) false))) (do (shen.unbindv V2545 V2789) Result))) false))) (if (shen.pvar? V2544) (let A (shen.newpv V2789) (do (shen.bindv V2544 (cons list (cons A ())) V2789) (let Result (let V2556 (shen.lazyderef (tl V2543) V2789) (if (= () V2556) (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2556) (do (shen.bindv V2556 () V2789) (let Result (let Hyp (tl V2534) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons list (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2556 V2789) Result))) false))) (do (shen.unbindv V2544 V2789) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2557 (shen.lazyderef V2787 V2789) (if (cons? V2557) (let V2558 (shen.lazyderef (hd V2557) V2789) (if (cons? V2558) (let V2559 (shen.lazyderef (hd V2558) V2789) (if (cons? V2559) (let V2560 (shen.lazyderef (hd V2559) V2789) (if (= @p V2560) (let V2561 (shen.lazyderef (tl V2559) V2789) (if (cons? V2561) (let X (hd V2561) (let V2562 (shen.lazyderef (tl V2561) V2789) (if (cons? V2562) (let Y (hd V2562) (let V2563 (shen.lazyderef (tl V2562) V2789) (if (= () V2563) (let V2564 (shen.lazyderef (tl V2558) V2789) (if (cons? V2564) (let V2565 (shen.lazyderef (hd V2564) V2789) (if (= : V2565) (let V2566 (shen.lazyderef (tl V2564) V2789) (if (cons? V2566) (let V2567 (shen.lazyderef (hd V2566) V2789) (if (cons? V2567) (let A (hd V2567) (let V2568 (shen.lazyderef (tl V2567) V2789) (if (cons? V2568) (let V2569 (shen.lazyderef (hd V2568) V2789) (if (= * V2569) (let V2570 (shen.lazyderef (tl V2568) V2789) (if (cons? V2570) (let B (hd V2570) (let V2571 (shen.lazyderef (tl V2570) V2789) (if (= () V2571) (let V2572 (shen.lazyderef (tl V2566) V2789) (if (= () V2572) (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2572) (do (shen.bindv V2572 () V2789) (let Result (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2572 V2789) Result))) false))) (if (shen.pvar? V2571) (do (shen.bindv V2571 () V2789) (let Result (let V2573 (shen.lazyderef (tl V2566) V2789) (if (= () V2573) (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2573) (do (shen.bindv V2573 () V2789) (let Result (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2573 V2789) Result))) false))) (do (shen.unbindv V2571 V2789) Result))) false)))) (if (shen.pvar? V2570) (let B (shen.newpv V2789) (do (shen.bindv V2570 (cons B ()) V2789) (let Result (let V2574 (shen.lazyderef (tl V2566) V2789) (if (= () V2574) (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2574) (do (shen.bindv V2574 () V2789) (let Result (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2574 V2789) Result))) false))) (do (shen.unbindv V2570 V2789) Result)))) false))) (if (shen.pvar? V2569) (do (shen.bindv V2569 * V2789) (let Result (let V2575 (shen.lazyderef (tl V2568) V2789) (if (cons? V2575) (let B (hd V2575) (let V2576 (shen.lazyderef (tl V2575) V2789) (if (= () V2576) (let V2577 (shen.lazyderef (tl V2566) V2789) (if (= () V2577) (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2577) (do (shen.bindv V2577 () V2789) (let Result (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2577 V2789) Result))) false))) (if (shen.pvar? V2576) (do (shen.bindv V2576 () V2789) (let Result (let V2578 (shen.lazyderef (tl V2566) V2789) (if (= () V2578) (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2578) (do (shen.bindv V2578 () V2789) (let Result (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2578 V2789) Result))) false))) (do (shen.unbindv V2576 V2789) Result))) false)))) (if (shen.pvar? V2575) (let B (shen.newpv V2789) (do (shen.bindv V2575 (cons B ()) V2789) (let Result (let V2579 (shen.lazyderef (tl V2566) V2789) (if (= () V2579) (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2579) (do (shen.bindv V2579 () V2789) (let Result (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2579 V2789) Result))) false))) (do (shen.unbindv V2575 V2789) Result)))) false))) (do (shen.unbindv V2569 V2789) Result))) false))) (if (shen.pvar? V2568) (let B (shen.newpv V2789) (do (shen.bindv V2568 (cons * (cons B ())) V2789) (let Result (let V2580 (shen.lazyderef (tl V2566) V2789) (if (= () V2580) (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2580) (do (shen.bindv V2580 () V2789) (let Result (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2580 V2789) Result))) false))) (do (shen.unbindv V2568 V2789) Result)))) false)))) (if (shen.pvar? V2567) (let A (shen.newpv V2789) (let B (shen.newpv V2789) (do (shen.bindv V2567 (cons A (cons * (cons B ()))) V2789) (let Result (let V2581 (shen.lazyderef (tl V2566) V2789) (if (= () V2581) (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2581) (do (shen.bindv V2581 () V2789) (let Result (let Hyp (tl V2557) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (shen.lazyderef B V2789) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2581 V2789) Result))) false))) (do (shen.unbindv V2567 V2789) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2582 (shen.lazyderef V2787 V2789) (if (cons? V2582) (let V2583 (shen.lazyderef (hd V2582) V2789) (if (cons? V2583) (let V2584 (shen.lazyderef (hd V2583) V2789) (if (cons? V2584) (let V2585 (shen.lazyderef (hd V2584) V2789) (if (= @v V2585) (let V2586 (shen.lazyderef (tl V2584) V2789) (if (cons? V2586) (let X (hd V2586) (let V2587 (shen.lazyderef (tl V2586) V2789) (if (cons? V2587) (let Y (hd V2587) (let V2588 (shen.lazyderef (tl V2587) V2789) (if (= () V2588) (let V2589 (shen.lazyderef (tl V2583) V2789) (if (cons? V2589) (let V2590 (shen.lazyderef (hd V2589) V2789) (if (= : V2590) (let V2591 (shen.lazyderef (tl V2589) V2789) (if (cons? V2591) (let V2592 (shen.lazyderef (hd V2591) V2789) (if (cons? V2592) (let V2593 (shen.lazyderef (hd V2592) V2789) (if (= vector V2593) (let V2594 (shen.lazyderef (tl V2592) V2789) (if (cons? V2594) (let A (hd V2594) (let V2595 (shen.lazyderef (tl V2594) V2789) (if (= () V2595) (let V2596 (shen.lazyderef (tl V2591) V2789) (if (= () V2596) (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2596) (do (shen.bindv V2596 () V2789) (let Result (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2596 V2789) Result))) false))) (if (shen.pvar? V2595) (do (shen.bindv V2595 () V2789) (let Result (let V2597 (shen.lazyderef (tl V2591) V2789) (if (= () V2597) (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2597) (do (shen.bindv V2597 () V2789) (let Result (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2597 V2789) Result))) false))) (do (shen.unbindv V2595 V2789) Result))) false)))) (if (shen.pvar? V2594) (let A (shen.newpv V2789) (do (shen.bindv V2594 (cons A ()) V2789) (let Result (let V2598 (shen.lazyderef (tl V2591) V2789) (if (= () V2598) (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2598) (do (shen.bindv V2598 () V2789) (let Result (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2598 V2789) Result))) false))) (do (shen.unbindv V2594 V2789) Result)))) false))) (if (shen.pvar? V2593) (do (shen.bindv V2593 vector V2789) (let Result (let V2599 (shen.lazyderef (tl V2592) V2789) (if (cons? V2599) (let A (hd V2599) (let V2600 (shen.lazyderef (tl V2599) V2789) (if (= () V2600) (let V2601 (shen.lazyderef (tl V2591) V2789) (if (= () V2601) (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2601) (do (shen.bindv V2601 () V2789) (let Result (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2601 V2789) Result))) false))) (if (shen.pvar? V2600) (do (shen.bindv V2600 () V2789) (let Result (let V2602 (shen.lazyderef (tl V2591) V2789) (if (= () V2602) (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2602) (do (shen.bindv V2602 () V2789) (let Result (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2602 V2789) Result))) false))) (do (shen.unbindv V2600 V2789) Result))) false)))) (if (shen.pvar? V2599) (let A (shen.newpv V2789) (do (shen.bindv V2599 (cons A ()) V2789) (let Result (let V2603 (shen.lazyderef (tl V2591) V2789) (if (= () V2603) (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2603) (do (shen.bindv V2603 () V2789) (let Result (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2603 V2789) Result))) false))) (do (shen.unbindv V2599 V2789) Result)))) false))) (do (shen.unbindv V2593 V2789) Result))) false))) (if (shen.pvar? V2592) (let A (shen.newpv V2789) (do (shen.bindv V2592 (cons vector (cons A ())) V2789) (let Result (let V2604 (shen.lazyderef (tl V2591) V2789) (if (= () V2604) (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2604) (do (shen.bindv V2604 () V2789) (let Result (let Hyp (tl V2582) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons (shen.lazyderef A V2789) ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons (cons vector (cons (shen.lazyderef A V2789) ())) ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2604 V2789) Result))) false))) (do (shen.unbindv V2592 V2789) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2605 (shen.lazyderef V2787 V2789) (if (cons? V2605) (let V2606 (shen.lazyderef (hd V2605) V2789) (if (cons? V2606) (let V2607 (shen.lazyderef (hd V2606) V2789) (if (cons? V2607) (let V2608 (shen.lazyderef (hd V2607) V2789) (if (= @s V2608) (let V2609 (shen.lazyderef (tl V2607) V2789) (if (cons? V2609) (let X (hd V2609) (let V2610 (shen.lazyderef (tl V2609) V2789) (if (cons? V2610) (let Y (hd V2610) (let V2611 (shen.lazyderef (tl V2610) V2789) (if (= () V2611) (let V2612 (shen.lazyderef (tl V2606) V2789) (if (cons? V2612) (let V2613 (shen.lazyderef (hd V2612) V2789) (if (= : V2613) (let V2614 (shen.lazyderef (tl V2612) V2789) (if (cons? V2614) (let V2615 (shen.lazyderef (hd V2614) V2789) (if (= string V2615) (let V2616 (shen.lazyderef (tl V2614) V2789) (if (= () V2616) (let Hyp (tl V2605) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons string ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2616) (do (shen.bindv V2616 () V2789) (let Result (let Hyp (tl V2605) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons string ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2616 V2789) Result))) false))) (if (shen.pvar? V2615) (do (shen.bindv V2615 string V2789) (let Result (let V2617 (shen.lazyderef (tl V2614) V2789) (if (= () V2617) (let Hyp (tl V2605) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons string ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (if (shen.pvar? V2617) (do (shen.bindv V2617 () V2789) (let Result (let Hyp (tl V2605) (do (shen.incinfs) (bind V2788 (cons (cons (shen.lazyderef X V2789) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2789) (cons : (cons string ()))) (shen.lazyderef Hyp V2789))) V2789 V2790))) (do (shen.unbindv V2617 V2789) Result))) false))) (do (shen.unbindv V2615 V2789) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2618 (shen.lazyderef V2787 V2789) (if (cons? V2618) (let X (hd V2618) (let Hyp (tl V2618) (let NewHyps (shen.newpv V2789) (do (shen.incinfs) (bind V2788 (cons (shen.lazyderef X V2789) (shen.lazyderef NewHyps V2789)) V2789 (freeze (shen.t*-hyps Hyp NewHyps V2789 V2790))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2803 V2804 V2805 V2806) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2803 V2805)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2804 V2805) 1) (do (pr "
> " (stoutput)) (do (shen.pause-for-user (value *language*)) (thaw V2806))))))))) (true (thaw V2806))))

(defun shen.line () (let Infs (inferences) (pr (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2807) (cond ((and (cons? V2807) (and (cons? (tl V2807)) (and (= : (hd (tl V2807))) (and (cons? (tl (tl V2807))) (= () (tl (tl (tl V2807)))))))) (pr (shen.app (hd V2807) (cn " : " (shen.app (hd (tl (tl V2807))) "" shen.r)) shen.r) (stoutput))) (true (pr (shen.app V2807 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2810 V2811) (cond ((= () V2810) shen.skip) ((cons? V2810) (do (pr (shen.app V2811 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2810)) (do (nl 1) (shen.show-assumptions (tl V2810) (+ V2811 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user (V2816) (cond ((= "Common Lisp" V2816) (let I (FORMAT () "~C" (READ-CHAR)) (if (= I "a") (simple-error "input aborted
") (nl 1)))) (true (let I (shen.read-char) (if (= I "a") (simple-error "input aborted
") (nl 1))))))

(defun shen.read-char () (shen.read-char-h (read-byte (stinput)) 0))

(defun shen.read-char-h (V2819 V2820) (cond ((and (= -1 V2819) (= 0 V2820)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 0 V2820) (shen.read-char-h (read-byte (stinput)) 0)) ((and (= -1 V2819) (= 1 V2820)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 1 V2820) (n->string V2819)) (true (shen.sys-error shen.read-char-h))))

(defun shen.typedf? (V2821) (element? V2821 (value shen.*signedfuncs*)))

(defun shen.sigf (V2822) (concat shen.type-signature-of- V2822))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2823 V2824 V2825 V2826) (let Case (let V2521 (shen.lazyderef V2824 V2825) (if (= number V2521) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2823 V2825)) V2825 V2826)) (if (shen.pvar? V2521) (do (shen.bindv V2521 number V2825) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2823 V2825)) V2825 V2826)) (do (shen.unbindv V2521 V2825) Result))) false))) (if (= Case false) (let Case (let V2522 (shen.lazyderef V2824 V2825) (if (= boolean V2522) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2823 V2825)) V2825 V2826)) (if (shen.pvar? V2522) (do (shen.bindv V2522 boolean V2825) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2823 V2825)) V2825 V2826)) (do (shen.unbindv V2522 V2825) Result))) false))) (if (= Case false) (let Case (let V2523 (shen.lazyderef V2824 V2825) (if (= string V2523) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2823 V2825)) V2825 V2826)) (if (shen.pvar? V2523) (do (shen.bindv V2523 string V2825) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2823 V2825)) V2825 V2826)) (do (shen.unbindv V2523 V2825) Result))) false))) (if (= Case false) (let Case (let V2524 (shen.lazyderef V2824 V2825) (if (= symbol V2524) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2823 V2825)) V2825 (freeze (fwhen (not (shen.placeholder? (shen.lazyderef V2823 V2825))) V2825 V2826)))) (if (shen.pvar? V2524) (do (shen.bindv V2524 symbol V2825) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2823 V2825)) V2825 (freeze (fwhen (not (shen.placeholder? (shen.lazyderef V2823 V2825))) V2825 V2826)))) (do (shen.unbindv V2524 V2825) Result))) false))) (if (= Case false) (let V2525 (shen.lazyderef V2823 V2825) (if (= () V2525) (let V2526 (shen.lazyderef V2824 V2825) (if (cons? V2526) (let V2527 (shen.lazyderef (hd V2526) V2825) (if (= list V2527) (let V2528 (shen.lazyderef (tl V2526) V2825) (if (cons? V2528) (let A (hd V2528) (let V2529 (shen.lazyderef (tl V2528) V2825) (if (= () V2529) (do (shen.incinfs) (thaw V2826)) (if (shen.pvar? V2529) (do (shen.bindv V2529 () V2825) (let Result (do (shen.incinfs) (thaw V2826)) (do (shen.unbindv V2529 V2825) Result))) false)))) (if (shen.pvar? V2528) (let A (shen.newpv V2825) (do (shen.bindv V2528 (cons A ()) V2825) (let Result (do (shen.incinfs) (thaw V2826)) (do (shen.unbindv V2528 V2825) Result)))) false))) (if (shen.pvar? V2527) (do (shen.bindv V2527 list V2825) (let Result (let V2530 (shen.lazyderef (tl V2526) V2825) (if (cons? V2530) (let A (hd V2530) (let V2531 (shen.lazyderef (tl V2530) V2825) (if (= () V2531) (do (shen.incinfs) (thaw V2826)) (if (shen.pvar? V2531) (do (shen.bindv V2531 () V2825) (let Result (do (shen.incinfs) (thaw V2826)) (do (shen.unbindv V2531 V2825) Result))) false)))) (if (shen.pvar? V2530) (let A (shen.newpv V2825) (do (shen.bindv V2530 (cons A ()) V2825) (let Result (do (shen.incinfs) (thaw V2826)) (do (shen.unbindv V2530 V2825) Result)))) false))) (do (shen.unbindv V2527 V2825) Result))) false))) (if (shen.pvar? V2526) (let A (shen.newpv V2825) (do (shen.bindv V2526 (cons list (cons A ())) V2825) (let Result (do (shen.incinfs) (thaw V2826)) (do (shen.unbindv V2526 V2825) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.placeholder? (V2827) (and (symbol? V2827) (shen.placeholder-help? (str V2827))))

(defun shen.placeholder-help? (V2834) (cond ((and (shen.+string? V2834) (and (= "&" (pos V2834 0)) (and (shen.+string? (tlstr V2834)) (= "&" (pos (tlstr V2834) 0))))) true) (true false)))

(defun shen.by_hypothesis (V2835 V2836 V2837 V2838 V2839) (let Case (let V2512 (shen.lazyderef V2837 V2838) (if (cons? V2512) (let V2513 (shen.lazyderef (hd V2512) V2838) (if (cons? V2513) (let Y (hd V2513) (let V2514 (shen.lazyderef (tl V2513) V2838) (if (cons? V2514) (let V2515 (shen.lazyderef (hd V2514) V2838) (if (= : V2515) (let V2516 (shen.lazyderef (tl V2514) V2838) (if (cons? V2516) (let B (hd V2516) (let V2517 (shen.lazyderef (tl V2516) V2838) (if (= () V2517) (do (shen.incinfs) (identical V2835 Y V2838 (freeze (unify! V2836 B V2838 V2839)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2518 (shen.lazyderef V2837 V2838) (if (cons? V2518) (let Hyp (tl V2518) (do (shen.incinfs) (shen.by_hypothesis V2835 V2836 Hyp V2838 V2839))) false)) Case)))

(defun shen.t*-def (V2840 V2841 V2842 V2843 V2844) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2506 (shen.lazyderef V2840 V2843) (if (cons? V2506) (let V2507 (shen.lazyderef (hd V2506) V2843) (if (= define V2507) (let V2508 (shen.lazyderef (tl V2506) V2843) (if (cons? V2508) (let F (hd V2508) (let X (tl V2508) (let Error (shen.newpv V2843) (let Sig+Rules (shen.newpv V2843) (let Vars (shen.newpv V2843) (let Rules (shen.newpv V2843) (let Sig&& (shen.newpv V2843) (let Declare (shen.newpv V2843) (let Sig (shen.newpv V2843) (do (shen.incinfs) (bind Sig+Rules (compile shen.<sig+rules> (shen.lazyderef X V2843) ()) V2843 (freeze (bind Error (if (= (shen.lazyderef Sig+Rules V2843) (fail)) (shen.errordef (shen.lazyderef F V2843)) shen.skip) V2843 (freeze (bind Sig (hd (shen.lazyderef Sig+Rules V2843)) V2843 (freeze (bind Rules (tl (shen.lazyderef Sig+Rules V2843)) V2843 (freeze (bind Vars (shen.extract_vars (shen.lazyderef Sig V2843)) V2843 (freeze (bind Sig&& (shen.placeholders (shen.lazyderef Sig V2843) (shen.lazyderef Vars V2843)) V2843 (freeze (cut Throwcontrol V2843 (freeze (shen.t*-rules Rules Sig&& 1 F (cons (cons F (cons : (cons Sig&& ()))) V2842) V2843 (freeze (bind Declare (declare (shen.lazyderef F V2843) (shen.lazyderef Sig V2843)) V2843 (freeze (unify! V2841 Sig V2843 V2844))))))))))))))))))))))))))))) false)) false)) false)))))

(defun shen.<sig+rules> (V2849) (let Result (let Parse_shen.<signature> (shen.<signature> V2849) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<trules> (shen.<trules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<trules>)) (shen.pair (hd Parse_shen.<trules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<trules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.placeholders (V2854 V2855) (cond ((cons? V2854) (map (lambda Z (shen.placeholders Z V2855)) V2854)) ((element? V2854 V2855) (concat && V2854)) (true V2854)))

(defun shen.<trules> (V2860) (let Result (let Parse_shen.<trule> (shen.<trule> V2860) (if (not (= (fail) Parse_shen.<trule>)) (let Parse_shen.<trules> (shen.<trules> Parse_shen.<trule>) (if (not (= (fail) Parse_shen.<trules>)) (shen.pair (hd Parse_shen.<trules>) (cons (shen.hdtl Parse_shen.<trule>) (shen.hdtl Parse_shen.<trules>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<trule> (shen.<trule> V2860) (if (not (= (fail) Parse_shen.<trule>)) (shen.pair (hd Parse_shen.<trule>) (cons (shen.hdtl Parse_shen.<trule>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<trule> (V2865) (let Result (let Parse_shen.<patterns> (shen.<patterns> V2865) (if (not (= (fail) Parse_shen.<patterns>)) (let Parse_shen.<arrow> (shen.<arrow> Parse_shen.<patterns>) (if (not (= (fail) Parse_shen.<arrow>)) (let Parse_shen.<action> (shen.<action> Parse_shen.<arrow>) (if (not (= (fail) Parse_shen.<action>)) (let Parse_shen.<guard?> (shen.<guard?> Parse_shen.<action>) (if (not (= (fail) Parse_shen.<guard?>)) (shen.pair (hd Parse_shen.<guard?>) (let Parse_Vars (shen.extract_vars (shen.hdtl Parse_shen.<patterns>)) (let Parse_Patterns (shen.placeholders (shen.hdtl Parse_shen.<patterns>) Parse_Vars) (let Parse_Action (shen.placeholders (shen.curry (shen.hdtl Parse_shen.<action>)) Parse_Vars) (let Parse_Guard (shen.placeholders (shen.curry (shen.hdtl Parse_shen.<guard?>)) Parse_Vars) (shen.form-rule Parse_Patterns (shen.hdtl Parse_shen.<arrow>) Parse_Action Parse_Guard)))))) (fail))) (fail))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.form-rule (V2866 V2867 V2868 V2869) (cond ((= shen.forward V2867) (cons V2866 (cons (if (= V2869 shen.skip) V2868 (cons where (cons V2869 (cons V2868 ())))) ()))) ((and (= shen.backward V2867) (and (cons? V2868) (and (cons? (hd V2868)) (and (= fail-if (hd (hd V2868))) (and (cons? (tl (hd V2868))) (and (= () (tl (tl (hd V2868)))) (and (cons? (tl V2868)) (= () (tl (tl V2868)))))))))) (cons V2866 (cons (if (= V2869 shen.skip) (cons where (cons (cons not (cons (cons (hd (tl (hd V2868))) (tl V2868)) ())) (tl V2868))) (cons where (cons (cons (cons and (cons V2869 ())) (cons (cons not (cons (cons (hd (tl (hd V2868))) (tl V2868)) ())) ())) (tl V2868)))) ()))) ((= shen.backward V2867) (cons V2866 (cons (if (= V2869 shen.skip) (cons where (cons (cons not (cons (cons (cons == (cons V2868 ())) (cons (cons fail ()) ())) ())) (cons V2868 ()))) (cons where (cons (cons (cons and (cons V2869 ())) (cons (cons not (cons (cons (cons == (cons V2868 ())) (cons (cons fail ()) ())) ())) ())) (cons V2868 ())))) ()))) (true (shen.sys-error shen.form-rule))))

(defun shen.<guard?> (V2874) (let Result (if (and (cons? (hd V2874)) (= where (hd (hd V2874)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd V2874)) (shen.hdtl V2874))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (shen.hdtl Parse_shen.<guard>)) (fail))) (fail)) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V2874) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<arrow> (V2879) (let Result (if (and (cons? (hd V2879)) (= -> (hd (hd V2879)))) (shen.pair (hd (shen.pair (tl (hd V2879)) (shen.hdtl V2879))) shen.forward) (fail)) (if (= Result (fail)) (let Result (if (and (cons? (hd V2879)) (= <- (hd (hd V2879)))) (shen.pair (hd (shen.pair (tl (hd V2879)) (shen.hdtl V2879))) shen.backward) (fail)) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.errordef (V2880) (simple-error (cn "syntax error in " (shen.app V2880 "
" shen.a))))

(defun shen.t*-rules (V2881 V2882 V2883 V2884 V2885 V2886 V2887) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2501 (shen.lazyderef V2881 V2886) (if (= () V2501) (do (shen.incinfs) (thaw V2887)) false)) (if (= Case false) (let V2502 (shen.lazyderef V2881 V2886) (if (cons? V2502) (let Rule (hd V2502) (let Rules (tl V2502) (let M (shen.newpv V2886) (do (shen.incinfs) (shen.t*-rule Rule V2882 V2883 V2884 V2885 V2886 (freeze (cut Throwcontrol V2886 (freeze (bind M (+ (shen.lazyderef V2883 V2886) 1) V2886 (freeze (shen.t*-rules Rules V2882 M V2884 V2885 V2886 V2887))))))))))) false)) Case)))))

(defun shen.t*-rule (V2888 V2889 V2890 V2891 V2892 V2893 V2894) (let Case (do (shen.incinfs) (shen.t*-ruleh V2888 V2889 V2892 V2893 V2894)) (if (= Case false) (let Error (shen.newpv V2893) (do (shen.incinfs) (bind Error (shen.type-insecure-rule-error-message (shen.lazyderef V2890 V2893) (shen.lazyderef V2891 V2893)) V2893 V2894))) Case)))

(defun shen.t*-ruleh (V2895 V2896 V2897 V2898 V2899) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2478 (shen.lazyderef V2895 V2898) (if (cons? V2478) (let V2479 (shen.lazyderef (hd V2478) V2898) (if (= () V2479) (let V2480 (shen.lazyderef (tl V2478) V2898) (if (cons? V2480) (let Result (hd V2480) (let V2481 (shen.lazyderef (tl V2480) V2898) (if (= () V2481) (let V2482 (shen.lazyderef V2896 V2898) (if (cons? V2482) (let V2483 (shen.lazyderef (hd V2482) V2898) (if (= --> V2483) (let V2484 (shen.lazyderef (tl V2482) V2898) (if (cons? V2484) (let A (hd V2484) (let V2485 (shen.lazyderef (tl V2484) V2898) (if (= () V2485) (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (if (shen.pvar? V2485) (do (shen.bindv V2485 () V2898) (let Result (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (do (shen.unbindv V2485 V2898) Result))) false)))) (if (shen.pvar? V2484) (let A (shen.newpv V2898) (do (shen.bindv V2484 (cons A ()) V2898) (let Result (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (do (shen.unbindv V2484 V2898) Result)))) false))) (if (shen.pvar? V2483) (do (shen.bindv V2483 --> V2898) (let Result (let V2486 (shen.lazyderef (tl V2482) V2898) (if (cons? V2486) (let A (hd V2486) (let V2487 (shen.lazyderef (tl V2486) V2898) (if (= () V2487) (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (if (shen.pvar? V2487) (do (shen.bindv V2487 () V2898) (let Result (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (do (shen.unbindv V2487 V2898) Result))) false)))) (if (shen.pvar? V2486) (let A (shen.newpv V2898) (do (shen.bindv V2486 (cons A ()) V2898) (let Result (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (do (shen.unbindv V2486 V2898) Result)))) false))) (do (shen.unbindv V2483 V2898) Result))) false))) (if (shen.pvar? V2482) (let A (shen.newpv V2898) (do (shen.bindv V2482 (cons --> (cons A ())) V2898) (let Result (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (do (shen.unbindv V2482 V2898) Result)))) false))) false))) false)) false)) false)) (if (= Case false) (let V2488 (shen.lazyderef V2895 V2898) (if (cons? V2488) (let Patterns (hd V2488) (let V2489 (shen.lazyderef (tl V2488) V2898) (if (cons? V2489) (let Result (hd V2489) (let V2490 (shen.lazyderef (tl V2489) V2898) (if (= () V2490) (let NewHyp (shen.newpv V2898) (let B (shen.newpv V2898) (let AllHyp (shen.newpv V2898) (do (shen.incinfs) (shen.t*-patterns Patterns V2896 NewHyp B V2898 (freeze (cut Throwcontrol V2898 (freeze (shen.conc NewHyp V2897 AllHyp V2898 (freeze (cut Throwcontrol V2898 (freeze (shen.th* Result B AllHyp V2898 V2899))))))))))))) false))) false))) false)) Case)))))

(defun shen.type-insecure-rule-error-message (V2900 V2901) (simple-error (cn "type error in rule " (shen.app V2900 (cn " of " (shen.app V2901 "
" shen.a)) shen.a))))

(defun shen.t*-patterns (V2902 V2903 V2904 V2905 V2906 V2907) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2459 (shen.lazyderef V2902 V2906) (if (= () V2459) (let V2460 (shen.lazyderef V2904 V2906) (if (= () V2460) (do (shen.incinfs) (unify! V2905 V2903 V2906 V2907)) (if (shen.pvar? V2460) (do (shen.bindv V2460 () V2906) (let Result (do (shen.incinfs) (unify! V2905 V2903 V2906 V2907)) (do (shen.unbindv V2460 V2906) Result))) false))) false)) (if (= Case false) (let V2461 (shen.lazyderef V2902 V2906) (if (cons? V2461) (let Pattern2453 (hd V2461) (let Patterns (tl V2461) (let V2462 (shen.lazyderef V2903 V2906) (if (cons? V2462) (let A2454 (hd V2462) (let V2463 (shen.lazyderef (tl V2462) V2906) (if (cons? V2463) (let V2464 (shen.lazyderef (hd V2463) V2906) (if (= --> V2464) (let V2465 (shen.lazyderef (tl V2463) V2906) (if (cons? V2465) (let B (hd V2465) (let V2466 (shen.lazyderef (tl V2465) V2906) (if (= () V2466) (let V2467 (shen.lazyderef V2904 V2906) (if (cons? V2467) (let V2468 (shen.lazyderef (hd V2467) V2906) (if (cons? V2468) (let Pattern (hd V2468) (let V2469 (shen.lazyderef (tl V2468) V2906) (if (cons? V2469) (let V2470 (shen.lazyderef (hd V2469) V2906) (if (= : V2470) (let V2471 (shen.lazyderef (tl V2469) V2906) (if (cons? V2471) (let A (hd V2471) (let V2472 (shen.lazyderef (tl V2471) V2906) (if (= () V2472) (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (if (shen.pvar? V2472) (do (shen.bindv V2472 () V2906) (let Result (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (do (shen.unbindv V2472 V2906) Result))) false)))) (if (shen.pvar? V2471) (let A (shen.newpv V2906) (do (shen.bindv V2471 (cons A ()) V2906) (let Result (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (do (shen.unbindv V2471 V2906) Result)))) false))) (if (shen.pvar? V2470) (do (shen.bindv V2470 : V2906) (let Result (let V2473 (shen.lazyderef (tl V2469) V2906) (if (cons? V2473) (let A (hd V2473) (let V2474 (shen.lazyderef (tl V2473) V2906) (if (= () V2474) (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (if (shen.pvar? V2474) (do (shen.bindv V2474 () V2906) (let Result (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (do (shen.unbindv V2474 V2906) Result))) false)))) (if (shen.pvar? V2473) (let A (shen.newpv V2906) (do (shen.bindv V2473 (cons A ()) V2906) (let Result (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (do (shen.unbindv V2473 V2906) Result)))) false))) (do (shen.unbindv V2470 V2906) Result))) false))) (if (shen.pvar? V2469) (let A (shen.newpv V2906) (do (shen.bindv V2469 (cons : (cons A ())) V2906) (let Result (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (do (shen.unbindv V2469 V2906) Result)))) false)))) (if (shen.pvar? V2468) (let Pattern (shen.newpv V2906) (let A (shen.newpv V2906) (do (shen.bindv V2468 (cons Pattern (cons : (cons A ()))) V2906) (let Result (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (do (shen.unbindv V2468 V2906) Result))))) false))) (if (shen.pvar? V2467) (let Pattern (shen.newpv V2906) (let A (shen.newpv V2906) (let Hyp (shen.newpv V2906) (do (shen.bindv V2467 (cons (cons Pattern (cons : (cons A ()))) Hyp) V2906) (let Result (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907))))))))))))))) (do (shen.unbindv V2467 V2906) Result)))))) false))) false))) false)) false)) false))) false)))) false)) Case)))))

(defun shen.t*-assume (V2908 V2909 V2910 V2911) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2450 (shen.lazyderef V2908 V2910) (if (cons? V2450) (let X (hd V2450) (let Y (tl V2450) (let A1 (shen.newpv V2910) (let A2 (shen.newpv V2910) (do (shen.incinfs) (cut Throwcontrol V2910 (freeze (shen.t*-assume X A1 V2910 (freeze (shen.t*-assume Y A2 V2910 (freeze (bind V2909 (append (shen.lazyderef A1 V2910) (shen.lazyderef A2 V2910)) V2910 V2911)))))))))))) false)) (if (= Case false) (let Case (let A (shen.newpv V2910) (do (shen.incinfs) (fwhen (shen.placeholder? (shen.lazyderef V2908 V2910)) V2910 (freeze (bind V2909 (cons (cons (shen.lazyderef V2908 V2910) (cons : (cons (shen.lazyderef A V2910) ()))) ()) V2910 V2911))))) (if (= Case false) (let V2451 (shen.lazyderef V2909 V2910) (if (= () V2451) (do (shen.incinfs) (thaw V2911)) (if (shen.pvar? V2451) (do (shen.bindv V2451 () V2910) (let Result (do (shen.incinfs) (thaw V2911)) (do (shen.unbindv V2451 V2910) Result))) false))) Case)) Case)))))

(defun shen.conc (V2912 V2913 V2914 V2915 V2916) (let Case (let V2446 (shen.lazyderef V2912 V2915) (if (= () V2446) (do (shen.incinfs) (bind V2914 (shen.lazyderef V2913 V2915) V2915 V2916)) false)) (if (= Case false) (let V2447 (shen.lazyderef V2912 V2915) (if (cons? V2447) (let X (hd V2447) (let Y (tl V2447) (let Z (shen.newpv V2915) (do (shen.incinfs) (bind V2914 (cons (shen.lazyderef X V2915) (shen.lazyderef Z V2915)) V2915 (freeze (shen.conc Y V2913 Z V2915 V2916))))))) false)) Case)))

(defun shen.findallhelp (V2917 V2918 V2919 V2920 V2921 V2922) (let Case (do (shen.incinfs) (call V2918 V2921 (freeze (shen.remember V2920 V2917 V2921 (freeze (fwhen false V2921 V2922)))))) (if (= Case false) (do (shen.incinfs) (bind V2919 (value (shen.lazyderef V2920 V2921)) V2921 V2922)) Case)))

(defun shen.remember (V2923 V2924 V2925 V2926) (let B (shen.newpv V2925) (do (shen.incinfs) (bind B (set (shen.deref V2923 V2925) (cons (shen.deref V2924 V2925) (value (shen.deref V2923 V2925)))) V2925 V2926))))

(defun findall (V2927 V2928 V2929 V2930 V2931) (let B (shen.newpv V2930) (let A (shen.newpv V2930) (do (shen.incinfs) (bind A (gensym shen.a) V2930 (freeze (bind B (set (shen.lazyderef A V2930) ()) V2930 (freeze (shen.findallhelp V2927 V2928 V2929 A V2930 V2931)))))))))

(defun shen.t*-defcc (V2932 V2933 V2934 V2935 V2936) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2419 (shen.lazyderef V2932 V2935) (if (cons? V2419) (let V2420 (shen.lazyderef (hd V2419) V2935) (if (= defcc V2420) (let V2421 (shen.lazyderef (tl V2419) V2935) (if (cons? V2421) (let F (hd V2421) (let V2422 (shen.lazyderef (tl V2421) V2935) (if (cons? V2422) (let V2423 (shen.lazyderef (hd V2422) V2935) (if (= { V2423) (let V2424 (shen.lazyderef (tl V2422) V2935) (if (cons? V2424) (let V2425 (shen.lazyderef (hd V2424) V2935) (if (cons? V2425) (let V2426 (shen.lazyderef (hd V2425) V2935) (if (= list V2426) (let V2427 (shen.lazyderef (tl V2425) V2935) (if (cons? V2427) (let A (hd V2427) (let V2428 (shen.lazyderef (tl V2427) V2935) (if (= () V2428) (let V2429 (shen.lazyderef (tl V2424) V2935) (if (cons? V2429) (let V2430 (shen.lazyderef (hd V2429) V2935) (if (= ==> V2430) (let V2431 (shen.lazyderef (tl V2429) V2935) (if (cons? V2431) (let B (hd V2431) (let V2432 (shen.lazyderef (tl V2431) V2935) (if (cons? V2432) (let V2433 (shen.lazyderef (hd V2432) V2935) (if (= } V2433) (let Rest (tl V2432) (let Rest& (shen.newpv V2935) (let Rest&& (shen.newpv V2935) (let Rules (shen.newpv V2935) (let ListA&& (shen.newpv V2935) (let B&& (shen.newpv V2935) (let Sig (shen.newpv V2935) (let Declare (shen.newpv V2935) (do (shen.incinfs) (bind Sig (shen.placeholders (cons (cons list (cons (shen.lazyderef A V2935) ())) (cons ==> (cons (shen.lazyderef B V2935) ()))) (shen.extract_vars (cons (cons list (cons (shen.lazyderef A V2935) ())) (cons ==> (cons (shen.lazyderef B V2935) ()))))) V2935 (freeze (bind ListA&& (hd (shen.lazyderef Sig V2935)) V2935 (freeze (bind B&& (hd (tl (tl (shen.lazyderef Sig V2935)))) V2935 (freeze (bind Rest& (shen.plug-wildcards (shen.lazyderef Rest V2935)) V2935 (freeze (bind Rest&& (shen.placeholders (shen.lazyderef Rest& V2935) (shen.extract_vars (shen.lazyderef Rest& V2935))) V2935 (freeze (shen.get-rules Rules Rest&& V2935 (freeze (cut Throwcontrol V2935 (freeze (shen.tc-rules F Rules ListA&& B&& (cons (cons F (cons : (cons Sig ()))) V2934) 1 V2935 (freeze (unify V2933 (cons (cons list (cons A ())) (cons ==> (cons B ()))) V2935 (freeze (bind Declare (declare (shen.lazyderef F V2935) (cons (cons list (cons (shen.lazyderef A V2935) ())) (cons ==> (cons (shen.lazyderef B V2935) ())))) V2935 V2936)))))))))))))))))))))))))))) false)) false))) false)) false)) false)) false))) false)) false)) false)) false)) false)) false))) false)) false)) false)))))

(defun shen.plug-wildcards (V2937) (cond ((cons? V2937) (map shen.plug-wildcards V2937)) ((= V2937 _) (gensym (intern "X"))) (true V2937)))

(defun shen.get-rules (V2938 V2939 V2940 V2941) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2412 (shen.lazyderef V2938 V2940) (if (= () V2412) (let V2413 (shen.lazyderef V2939 V2940) (if (= () V2413) (do (shen.incinfs) (cut Throwcontrol V2940 V2941)) false)) (if (shen.pvar? V2412) (do (shen.bindv V2412 () V2940) (let Result (let V2414 (shen.lazyderef V2939 V2940) (if (= () V2414) (do (shen.incinfs) (cut Throwcontrol V2940 V2941)) false)) (do (shen.unbindv V2412 V2940) Result))) false))) (if (= Case false) (let V2415 (shen.lazyderef V2938 V2940) (if (cons? V2415) (let Rule (hd V2415) (let Rules (tl V2415) (let Other (shen.newpv V2940) (do (shen.incinfs) (shen.first-rule V2939 Rule Other V2940 (freeze (cut Throwcontrol V2940 (freeze (shen.get-rules Rules Other V2940 V2941))))))))) (if (shen.pvar? V2415) (let Rule (shen.newpv V2940) (let Rules (shen.newpv V2940) (do (shen.bindv V2415 (cons Rule Rules) V2940) (let Result (let Other (shen.newpv V2940) (do (shen.incinfs) (shen.first-rule V2939 Rule Other V2940 (freeze (cut Throwcontrol V2940 (freeze (shen.get-rules Rules Other V2940 V2941))))))) (do (shen.unbindv V2415 V2940) Result))))) false))) Case)))))

(defun shen.first-rule (V2942 V2943 V2944 V2945 V2946) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2405 (shen.lazyderef V2942 V2945) (if (cons? V2405) (let V2406 (shen.lazyderef (hd V2405) V2945) (if (= ; V2406) (let Other2400 (tl V2405) (let V2407 (shen.lazyderef V2943 V2945) (if (= () V2407) (do (shen.incinfs) (unify! V2944 Other2400 V2945 (freeze (cut Throwcontrol V2945 V2946)))) (if (shen.pvar? V2407) (do (shen.bindv V2407 () V2945) (let Result (do (shen.incinfs) (unify! V2944 Other2400 V2945 (freeze (cut Throwcontrol V2945 V2946)))) (do (shen.unbindv V2407 V2945) Result))) false)))) false)) false)) (if (= Case false) (let V2408 (shen.lazyderef V2942 V2945) (if (cons? V2408) (let X2401 (hd V2408) (let Rest (tl V2408) (let V2409 (shen.lazyderef V2943 V2945) (if (cons? V2409) (let X (hd V2409) (let Rule (tl V2409) (do (shen.incinfs) (unify! X X2401 V2945 (freeze (shen.first-rule Rest Rule V2944 V2945 V2946)))))) (if (shen.pvar? V2409) (let X (shen.newpv V2945) (let Rule (shen.newpv V2945) (do (shen.bindv V2409 (cons X Rule) V2945) (let Result (do (shen.incinfs) (unify! X X2401 V2945 (freeze (shen.first-rule Rest Rule V2944 V2945 V2946)))) (do (shen.unbindv V2409 V2945) Result))))) false))))) false)) Case)))))

(defun shen.tc-rules (V2947 V2948 V2949 V2950 V2951 V2952 V2953 V2954) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2394 (shen.lazyderef V2948 V2953) (if (= () V2394) (do (shen.incinfs) (thaw V2954)) false)) (if (= Case false) (let V2395 (shen.lazyderef V2948 V2953) (if (cons? V2395) (let Rule (hd V2395) (let Rules (tl V2395) (let V2396 (shen.lazyderef V2949 V2953) (if (cons? V2396) (let V2397 (shen.lazyderef (hd V2396) V2953) (if (= list V2397) (let V2398 (shen.lazyderef (tl V2396) V2953) (if (cons? V2398) (let A (hd V2398) (let V2399 (shen.lazyderef (tl V2398) V2953) (if (= () V2399) (let M (shen.newpv V2953) (do (shen.incinfs) (shen.tc-rule V2947 Rule A V2950 V2951 V2952 V2953 (freeze (bind M (+ (shen.deref V2952 V2953) 1) V2953 (freeze (cut Throwcontrol V2953 (freeze (shen.tc-rules V2947 Rules (cons list (cons A ())) V2950 V2951 M V2953 V2954))))))))) false))) false)) false)) false)))) false)) Case)))))

(defun shen.tc-rule (V2955 V2956 V2957 V2958 V2959 V2960 V2961 V2962) (let Case (do (shen.incinfs) (shen.check-defcc-rule V2956 V2957 V2958 V2959 V2961 V2962)) (if (= Case false) (let Err (shen.newpv V2961) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2960 V2961) (cn " of " (shen.app (shen.lazyderef V2955 V2961) "" shen.a)) shen.a))) V2961 V2962))) Case)))

(defun shen.check-defcc-rule (V2963 V2964 V2965 V2966 V2967 V2968) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Syntax (shen.newpv V2967) (let Semantics (shen.newpv V2967) (let SynHyps (shen.newpv V2967) (do (shen.incinfs) (shen.get-syntax+semantics Syntax Semantics V2963 V2967 (freeze (cut Throwcontrol V2967 (freeze (shen.syntax-hyps Syntax V2966 SynHyps V2964 V2967 (freeze (cut Throwcontrol V2967 (freeze (shen.syntax-check Syntax V2964 SynHyps V2967 (freeze (cut Throwcontrol V2967 (freeze (shen.semantics-check Semantics V2965 SynHyps V2967 V2968))))))))))))))))))))

(defun shen.syntax-hyps (V2969 V2970 V2971 V2972 V2973 V2974) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2365 (shen.lazyderef V2969 V2973) (if (= () V2365) (do (shen.incinfs) (unify! V2971 V2970 V2973 V2974)) false)) (if (= Case false) (let Case (let V2366 (shen.lazyderef V2969 V2973) (if (cons? V2366) (let V2367 (shen.lazyderef (hd V2366) V2973) (if (cons? V2367) (let X (hd V2367) (let Y (tl V2367) (let Z (tl V2366) (let W (shen.newpv V2973) (do (shen.incinfs) (cut Throwcontrol V2973 (freeze (shen.conc (cons X Y) Z W V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps W V2970 V2971 V2972 V2973 V2974)))))))))))) false)) false)) (if (= Case false) (let Case (let V2368 (shen.lazyderef V2969 V2973) (if (cons? V2368) (let X2359 (hd V2368) (let Y (tl V2368) (let V2369 (shen.lazyderef V2971 V2973) (if (cons? V2369) (let V2370 (shen.lazyderef (hd V2369) V2973) (if (cons? V2370) (let X (hd V2370) (let V2371 (shen.lazyderef (tl V2370) V2973) (if (cons? V2371) (let V2372 (shen.lazyderef (hd V2371) V2973) (if (= : V2372) (let V2373 (shen.lazyderef (tl V2371) V2973) (if (cons? V2373) (let A2360 (hd V2373) (let V2374 (shen.lazyderef (tl V2373) V2973) (if (= () V2374) (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (if (shen.pvar? V2374) (do (shen.bindv V2374 () V2973) (let Result (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (do (shen.unbindv V2374 V2973) Result))) false)))) (if (shen.pvar? V2373) (let A2360 (shen.newpv V2973) (do (shen.bindv V2373 (cons A2360 ()) V2973) (let Result (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (do (shen.unbindv V2373 V2973) Result)))) false))) (if (shen.pvar? V2372) (do (shen.bindv V2372 : V2973) (let Result (let V2375 (shen.lazyderef (tl V2371) V2973) (if (cons? V2375) (let A2360 (hd V2375) (let V2376 (shen.lazyderef (tl V2375) V2973) (if (= () V2376) (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (if (shen.pvar? V2376) (do (shen.bindv V2376 () V2973) (let Result (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (do (shen.unbindv V2376 V2973) Result))) false)))) (if (shen.pvar? V2375) (let A2360 (shen.newpv V2973) (do (shen.bindv V2375 (cons A2360 ()) V2973) (let Result (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (do (shen.unbindv V2375 V2973) Result)))) false))) (do (shen.unbindv V2372 V2973) Result))) false))) (if (shen.pvar? V2371) (let A2360 (shen.newpv V2973) (do (shen.bindv V2371 (cons : (cons A2360 ())) V2973) (let Result (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (do (shen.unbindv V2371 V2973) Result)))) false)))) (if (shen.pvar? V2370) (let X (shen.newpv V2973) (let A2360 (shen.newpv V2973) (do (shen.bindv V2370 (cons X (cons : (cons A2360 ()))) V2973) (let Result (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (do (shen.unbindv V2370 V2973) Result))))) false))) (if (shen.pvar? V2369) (let X (shen.newpv V2973) (let A2360 (shen.newpv V2973) (let SynHyps (shen.newpv V2973) (do (shen.bindv V2369 (cons (cons X (cons : (cons A2360 ()))) SynHyps) V2973) (let Result (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974)))))))))) (do (shen.unbindv V2369 V2973) Result)))))) false))))) false)) (if (= Case false) (let V2377 (shen.lazyderef V2969 V2973) (if (cons? V2377) (let Y (tl V2377) (do (shen.incinfs) (shen.syntax-hyps Y V2970 V2971 V2972 V2973 V2974))) false)) Case)) Case)) Case)))))

(defun shen.get-syntax+semantics (V2975 V2976 V2977 V2978 V2979) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2331 (shen.lazyderef V2975 V2978) (if (= () V2331) (let V2332 (shen.lazyderef V2977 V2978) (if (cons? V2332) (let V2333 (shen.lazyderef (hd V2332) V2978) (if (= := V2333) (let V2334 (shen.lazyderef (tl V2332) V2978) (if (cons? V2334) (let Semantics (hd V2334) (let V2335 (shen.lazyderef (tl V2334) V2978) (if (= () V2335) (do (shen.incinfs) (cut Throwcontrol V2978 (freeze (bind V2976 (shen.lazyderef Semantics V2978) V2978 V2979)))) false))) false)) false)) false)) (if (shen.pvar? V2331) (do (shen.bindv V2331 () V2978) (let Result (let V2336 (shen.lazyderef V2977 V2978) (if (cons? V2336) (let V2337 (shen.lazyderef (hd V2336) V2978) (if (= := V2337) (let V2338 (shen.lazyderef (tl V2336) V2978) (if (cons? V2338) (let Semantics (hd V2338) (let V2339 (shen.lazyderef (tl V2338) V2978) (if (= () V2339) (do (shen.incinfs) (cut Throwcontrol V2978 (freeze (bind V2976 (shen.lazyderef Semantics V2978) V2978 V2979)))) false))) false)) false)) false)) (do (shen.unbindv V2331 V2978) Result))) false))) (if (= Case false) (let Case (let V2340 (shen.lazyderef V2975 V2978) (if (= () V2340) (let V2341 (shen.lazyderef V2977 V2978) (if (cons? V2341) (let V2342 (shen.lazyderef (hd V2341) V2978) (if (= := V2342) (let V2343 (shen.lazyderef (tl V2341) V2978) (if (cons? V2343) (let Semantics (hd V2343) (let V2344 (shen.lazyderef (tl V2343) V2978) (if (cons? V2344) (let V2345 (shen.lazyderef (hd V2344) V2978) (if (= where V2345) (let V2346 (shen.lazyderef (tl V2344) V2978) (if (cons? V2346) (let G (hd V2346) (let V2347 (shen.lazyderef (tl V2346) V2978) (if (= () V2347) (do (shen.incinfs) (cut Throwcontrol V2978 (freeze (bind V2976 (cons where (cons (shen.lazyderef G V2978) (cons (shen.lazyderef Semantics V2978) ()))) V2978 V2979)))) false))) false)) false)) false))) false)) false)) false)) (if (shen.pvar? V2340) (do (shen.bindv V2340 () V2978) (let Result (let V2348 (shen.lazyderef V2977 V2978) (if (cons? V2348) (let V2349 (shen.lazyderef (hd V2348) V2978) (if (= := V2349) (let V2350 (shen.lazyderef (tl V2348) V2978) (if (cons? V2350) (let Semantics (hd V2350) (let V2351 (shen.lazyderef (tl V2350) V2978) (if (cons? V2351) (let V2352 (shen.lazyderef (hd V2351) V2978) (if (= where V2352) (let V2353 (shen.lazyderef (tl V2351) V2978) (if (cons? V2353) (let G (hd V2353) (let V2354 (shen.lazyderef (tl V2353) V2978) (if (= () V2354) (do (shen.incinfs) (cut Throwcontrol V2978 (freeze (bind V2976 (cons where (cons (shen.lazyderef G V2978) (cons (shen.lazyderef Semantics V2978) ()))) V2978 V2979)))) false))) false)) false)) false))) false)) false)) false)) (do (shen.unbindv V2340 V2978) Result))) false))) (if (= Case false) (let V2355 (shen.lazyderef V2975 V2978) (if (cons? V2355) (let X2327 (hd V2355) (let Syntax (tl V2355) (let V2356 (shen.lazyderef V2977 V2978) (if (cons? V2356) (let X (hd V2356) (let Rule (tl V2356) (do (shen.incinfs) (unify! X X2327 V2978 (freeze (shen.get-syntax+semantics Syntax V2976 Rule V2978 V2979)))))) false)))) (if (shen.pvar? V2355) (let X2327 (shen.newpv V2978) (let Syntax (shen.newpv V2978) (do (shen.bindv V2355 (cons X2327 Syntax) V2978) (let Result (let V2357 (shen.lazyderef V2977 V2978) (if (cons? V2357) (let X (hd V2357) (let Rule (tl V2357) (do (shen.incinfs) (unify! X X2327 V2978 (freeze (shen.get-syntax+semantics Syntax V2976 Rule V2978 V2979)))))) false)) (do (shen.unbindv V2355 V2978) Result))))) false))) Case)) Case)))))

(defun shen.syntax-check (V2980 V2981 V2982 V2983 V2984) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2324 (shen.lazyderef V2980 V2983) (if (= () V2324) (do (shen.incinfs) (thaw V2984)) false)) (if (= Case false) (let Case (let V2325 (shen.lazyderef V2980 V2983) (if (cons? V2325) (let X (hd V2325) (let Syntax (tl V2325) (let C (shen.newpv V2983) (let X&& (shen.newpv V2983) (let B (shen.newpv V2983) (do (shen.incinfs) (fwhen (shen.grammar_symbol? (shen.lazyderef X V2983)) V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.t* (cons X (cons : (cons (cons (cons list (cons B ())) (cons ==> (cons C ()))) ()))) V2982 V2983 (freeze (cut Throwcontrol V2983 (freeze (bind X&& (concat && (shen.lazyderef X V2983)) V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.t* (cons X&& (cons : (cons (cons list (cons V2981 ())) ()))) (cons (cons X&& (cons : (cons (cons list (cons B ())) ()))) V2982) V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.syntax-check Syntax V2981 V2982 V2983 V2984))))))))))))))))))))))) false)) (if (= Case false) (let V2326 (shen.lazyderef V2980 V2983) (if (cons? V2326) (let X (hd V2326) (let Syntax (tl V2326) (do (shen.incinfs) (shen.t* (cons X (cons : (cons V2981 ()))) V2982 V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.syntax-check Syntax V2981 V2982 V2983 V2984)))))))) false)) Case)) Case)))))

(defun shen.semantics-check (V2985 V2986 V2987 V2988 V2989) (let Semantics* (shen.newpv V2988) (do (shen.incinfs) (bind Semantics* (shen.curry (shen.rename-semantics (shen.deref V2985 V2988))) V2988 (freeze (shen.t* (cons Semantics* (cons : (cons V2986 ()))) V2987 V2988 V2989))))))

(defun shen.rename-semantics (V2990) (cond ((cons? V2990) (cons (shen.rename-semantics (hd V2990)) (shen.rename-semantics (tl V2990)))) ((shen.grammar_symbol? V2990) (cons shen.<-sem (cons V2990 ()))) (true V2990)))



