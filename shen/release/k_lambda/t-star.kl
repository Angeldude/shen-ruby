"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2785 V2786) (let Curry (shen.curry V2785) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2786)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2787) (cond ((and (cons? V2787) (shen.special? (hd V2787))) (cons (hd V2787) (map shen.curry (tl V2787)))) ((and (cons? V2787) (and (cons? (tl V2787)) (shen.extraspecial? (hd V2787)))) V2787) ((and (cons? V2787) (and (cons? (tl V2787)) (cons? (tl (tl V2787))))) (shen.curry (cons (cons (hd V2787) (cons (hd (tl V2787)) ())) (tl (tl V2787))))) ((and (cons? V2787) (and (cons? (tl V2787)) (= () (tl (tl V2787))))) (cons (shen.curry (hd V2787)) (cons (shen.curry (hd (tl V2787))) ()))) (true V2787)))

(defun shen.special? (V2788) (element? V2788 (value shen.*special*)))

(defun shen.extraspecial? (V2789) (element? V2789 (value shen.*extraspecial*)))

(defun shen.t* (V2790 V2791 V2792 V2793) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2792) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2792 (freeze (bind Error (shen.errormaxinfs) V2792 V2793))))) (if (= Case false) (let Case (let V2779 (shen.lazyderef V2790 V2792) (if (= fail V2779) (do (shen.incinfs) (cut Throwcontrol V2792 (freeze (shen.prolog-failure V2792 V2793)))) false)) (if (= Case false) (let Case (let V2780 (shen.lazyderef V2790 V2792) (if (cons? V2780) (let X (hd V2780) (let V2781 (shen.lazyderef (tl V2780) V2792) (if (cons? V2781) (let V2782 (shen.lazyderef (hd V2781) V2792) (if (= : V2782) (let V2783 (shen.lazyderef (tl V2781) V2792) (if (cons? V2783) (let A (hd V2783) (let V2784 (shen.lazyderef (tl V2783) V2792) (if (= () V2784) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2792 (freeze (cut Throwcontrol V2792 (freeze (shen.th* X A V2791 V2792 V2793)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2792) (do (shen.incinfs) (shen.show V2790 V2791 V2792 (freeze (bind Datatypes (value shen.*datatypes*) V2792 (freeze (shen.udefs* V2790 V2791 Datatypes V2792 V2793))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2798) (cond ((= + V2798) (set shen.*shen-type-theory-enabled?* true)) ((= - V2798) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2807 V2808) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2809 V2810 V2811 V2812 V2813) (let Case (let V2775 (shen.lazyderef V2811 V2812) (if (cons? V2775) (let D (hd V2775) (do (shen.incinfs) (call (cons D (cons V2809 (cons V2810 ()))) V2812 V2813))) false)) (if (= Case false) (let V2776 (shen.lazyderef V2811 V2812) (if (cons? V2776) (let Ds (tl V2776) (do (shen.incinfs) (shen.udefs* V2809 V2810 Ds V2812 V2813))) false)) Case)))

(defun shen.th* (V2814 V2815 V2816 V2817 V2818) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2814 (cons : (cons V2815 ()))) V2816 V2817 (freeze (fwhen false V2817 V2818)))) (if (= Case false) (let Case (let F (shen.newpv V2817) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2814 V2817)) V2817 (freeze (bind F (shen.sigf (shen.lazyderef V2814 V2817)) V2817 (freeze (call (cons F (cons V2815 ())) V2817 V2818))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2814 V2815 V2817 V2818)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2814 V2815 V2816 V2817 V2818)) (if (= Case false) (let Case (let V2655 (shen.lazyderef V2814 V2817) (if (cons? V2655) (let F (hd V2655) (let V2656 (shen.lazyderef (tl V2655) V2817) (if (= () V2656) (do (shen.incinfs) (shen.th* F (cons --> (cons V2815 ())) V2816 V2817 V2818)) false))) false)) (if (= Case false) (let Case (let V2657 (shen.lazyderef V2814 V2817) (if (cons? V2657) (let F (hd V2657) (let V2658 (shen.lazyderef (tl V2657) V2817) (if (cons? V2658) (let X (hd V2658) (let V2659 (shen.lazyderef (tl V2658) V2817) (if (= () V2659) (let B (shen.newpv V2817) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2815 ()))) V2816 V2817 (freeze (shen.th* X B V2816 V2817 V2818))))) false))) false))) false)) (if (= Case false) (let Case (let V2660 (shen.lazyderef V2814 V2817) (if (cons? V2660) (let V2661 (shen.lazyderef (hd V2660) V2817) (if (= cons V2661) (let V2662 (shen.lazyderef (tl V2660) V2817) (if (cons? V2662) (let X (hd V2662) (let V2663 (shen.lazyderef (tl V2662) V2817) (if (cons? V2663) (let Y (hd V2663) (let V2664 (shen.lazyderef (tl V2663) V2817) (if (= () V2664) (let V2665 (shen.lazyderef V2815 V2817) (if (cons? V2665) (let V2666 (shen.lazyderef (hd V2665) V2817) (if (= list V2666) (let V2667 (shen.lazyderef (tl V2665) V2817) (if (cons? V2667) (let A (hd V2667) (let V2668 (shen.lazyderef (tl V2667) V2817) (if (= () V2668) (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons list (cons A ())) V2816 V2817 V2818)))) (if (shen.pvar? V2668) (do (shen.bindv V2668 () V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons list (cons A ())) V2816 V2817 V2818)))) (do (shen.unbindv V2668 V2817) Result))) false)))) (if (shen.pvar? V2667) (let A (shen.newpv V2817) (do (shen.bindv V2667 (cons A ()) V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons list (cons A ())) V2816 V2817 V2818)))) (do (shen.unbindv V2667 V2817) Result)))) false))) (if (shen.pvar? V2666) (do (shen.bindv V2666 list V2817) (let Result (let V2669 (shen.lazyderef (tl V2665) V2817) (if (cons? V2669) (let A (hd V2669) (let V2670 (shen.lazyderef (tl V2669) V2817) (if (= () V2670) (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons list (cons A ())) V2816 V2817 V2818)))) (if (shen.pvar? V2670) (do (shen.bindv V2670 () V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons list (cons A ())) V2816 V2817 V2818)))) (do (shen.unbindv V2670 V2817) Result))) false)))) (if (shen.pvar? V2669) (let A (shen.newpv V2817) (do (shen.bindv V2669 (cons A ()) V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons list (cons A ())) V2816 V2817 V2818)))) (do (shen.unbindv V2669 V2817) Result)))) false))) (do (shen.unbindv V2666 V2817) Result))) false))) (if (shen.pvar? V2665) (let A (shen.newpv V2817) (do (shen.bindv V2665 (cons list (cons A ())) V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons list (cons A ())) V2816 V2817 V2818)))) (do (shen.unbindv V2665 V2817) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2671 (shen.lazyderef V2814 V2817) (if (cons? V2671) (let V2672 (shen.lazyderef (hd V2671) V2817) (if (= @p V2672) (let V2673 (shen.lazyderef (tl V2671) V2817) (if (cons? V2673) (let X (hd V2673) (let V2674 (shen.lazyderef (tl V2673) V2817) (if (cons? V2674) (let Y (hd V2674) (let V2675 (shen.lazyderef (tl V2674) V2817) (if (= () V2675) (let V2676 (shen.lazyderef V2815 V2817) (if (cons? V2676) (let A (hd V2676) (let V2677 (shen.lazyderef (tl V2676) V2817) (if (cons? V2677) (let V2678 (shen.lazyderef (hd V2677) V2817) (if (= * V2678) (let V2679 (shen.lazyderef (tl V2677) V2817) (if (cons? V2679) (let B (hd V2679) (let V2680 (shen.lazyderef (tl V2679) V2817) (if (= () V2680) (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y B V2816 V2817 V2818)))) (if (shen.pvar? V2680) (do (shen.bindv V2680 () V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y B V2816 V2817 V2818)))) (do (shen.unbindv V2680 V2817) Result))) false)))) (if (shen.pvar? V2679) (let B (shen.newpv V2817) (do (shen.bindv V2679 (cons B ()) V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y B V2816 V2817 V2818)))) (do (shen.unbindv V2679 V2817) Result)))) false))) (if (shen.pvar? V2678) (do (shen.bindv V2678 * V2817) (let Result (let V2681 (shen.lazyderef (tl V2677) V2817) (if (cons? V2681) (let B (hd V2681) (let V2682 (shen.lazyderef (tl V2681) V2817) (if (= () V2682) (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y B V2816 V2817 V2818)))) (if (shen.pvar? V2682) (do (shen.bindv V2682 () V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y B V2816 V2817 V2818)))) (do (shen.unbindv V2682 V2817) Result))) false)))) (if (shen.pvar? V2681) (let B (shen.newpv V2817) (do (shen.bindv V2681 (cons B ()) V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y B V2816 V2817 V2818)))) (do (shen.unbindv V2681 V2817) Result)))) false))) (do (shen.unbindv V2678 V2817) Result))) false))) (if (shen.pvar? V2677) (let B (shen.newpv V2817) (do (shen.bindv V2677 (cons * (cons B ())) V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y B V2816 V2817 V2818)))) (do (shen.unbindv V2677 V2817) Result)))) false)))) (if (shen.pvar? V2676) (let A (shen.newpv V2817) (let B (shen.newpv V2817) (do (shen.bindv V2676 (cons A (cons * (cons B ()))) V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y B V2816 V2817 V2818)))) (do (shen.unbindv V2676 V2817) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2683 (shen.lazyderef V2814 V2817) (if (cons? V2683) (let V2684 (shen.lazyderef (hd V2683) V2817) (if (= @v V2684) (let V2685 (shen.lazyderef (tl V2683) V2817) (if (cons? V2685) (let X (hd V2685) (let V2686 (shen.lazyderef (tl V2685) V2817) (if (cons? V2686) (let Y (hd V2686) (let V2687 (shen.lazyderef (tl V2686) V2817) (if (= () V2687) (let V2688 (shen.lazyderef V2815 V2817) (if (cons? V2688) (let V2689 (shen.lazyderef (hd V2688) V2817) (if (= vector V2689) (let V2690 (shen.lazyderef (tl V2688) V2817) (if (cons? V2690) (let A (hd V2690) (let V2691 (shen.lazyderef (tl V2690) V2817) (if (= () V2691) (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons vector (cons A ())) V2816 V2817 V2818)))) (if (shen.pvar? V2691) (do (shen.bindv V2691 () V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons vector (cons A ())) V2816 V2817 V2818)))) (do (shen.unbindv V2691 V2817) Result))) false)))) (if (shen.pvar? V2690) (let A (shen.newpv V2817) (do (shen.bindv V2690 (cons A ()) V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons vector (cons A ())) V2816 V2817 V2818)))) (do (shen.unbindv V2690 V2817) Result)))) false))) (if (shen.pvar? V2689) (do (shen.bindv V2689 vector V2817) (let Result (let V2692 (shen.lazyderef (tl V2688) V2817) (if (cons? V2692) (let A (hd V2692) (let V2693 (shen.lazyderef (tl V2692) V2817) (if (= () V2693) (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons vector (cons A ())) V2816 V2817 V2818)))) (if (shen.pvar? V2693) (do (shen.bindv V2693 () V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons vector (cons A ())) V2816 V2817 V2818)))) (do (shen.unbindv V2693 V2817) Result))) false)))) (if (shen.pvar? V2692) (let A (shen.newpv V2817) (do (shen.bindv V2692 (cons A ()) V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons vector (cons A ())) V2816 V2817 V2818)))) (do (shen.unbindv V2692 V2817) Result)))) false))) (do (shen.unbindv V2689 V2817) Result))) false))) (if (shen.pvar? V2688) (let A (shen.newpv V2817) (do (shen.bindv V2688 (cons vector (cons A ())) V2817) (let Result (do (shen.incinfs) (shen.th* X A V2816 V2817 (freeze (shen.th* Y (cons vector (cons A ())) V2816 V2817 V2818)))) (do (shen.unbindv V2688 V2817) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2694 (shen.lazyderef V2814 V2817) (if (cons? V2694) (let V2695 (shen.lazyderef (hd V2694) V2817) (if (= @s V2695) (let V2696 (shen.lazyderef (tl V2694) V2817) (if (cons? V2696) (let X (hd V2696) (let V2697 (shen.lazyderef (tl V2696) V2817) (if (cons? V2697) (let Y (hd V2697) (let V2698 (shen.lazyderef (tl V2697) V2817) (if (= () V2698) (let V2699 (shen.lazyderef V2815 V2817) (if (= string V2699) (do (shen.incinfs) (shen.th* X string V2816 V2817 (freeze (shen.th* Y string V2816 V2817 V2818)))) (if (shen.pvar? V2699) (do (shen.bindv V2699 string V2817) (let Result (do (shen.incinfs) (shen.th* X string V2816 V2817 (freeze (shen.th* Y string V2816 V2817 V2818)))) (do (shen.unbindv V2699 V2817) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2700 (shen.lazyderef V2814 V2817) (if (cons? V2700) (let V2701 (shen.lazyderef (hd V2700) V2817) (if (= lambda V2701) (let V2702 (shen.lazyderef (tl V2700) V2817) (if (cons? V2702) (let X (hd V2702) (let V2703 (shen.lazyderef (tl V2702) V2817) (if (cons? V2703) (let Y (hd V2703) (let V2704 (shen.lazyderef (tl V2703) V2817) (if (= () V2704) (let V2705 (shen.lazyderef V2815 V2817) (if (cons? V2705) (let A (hd V2705) (let V2706 (shen.lazyderef (tl V2705) V2817) (if (cons? V2706) (let V2707 (shen.lazyderef (hd V2706) V2817) (if (= --> V2707) (let V2708 (shen.lazyderef (tl V2706) V2817) (if (cons? V2708) (let B (hd V2708) (let V2709 (shen.lazyderef (tl V2708) V2817) (if (= () V2709) (let Z (shen.newpv V2817) (let X&& (shen.newpv V2817) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (bind X&& (shen.placeholder) V2817 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2817) (shen.lazyderef X V2817) (shen.lazyderef Y V2817)) V2817 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2816) V2817 V2818)))))))))) (if (shen.pvar? V2709) (do (shen.bindv V2709 () V2817) (let Result (let Z (shen.newpv V2817) (let X&& (shen.newpv V2817) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (bind X&& (shen.placeholder) V2817 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2817) (shen.lazyderef X V2817) (shen.lazyderef Y V2817)) V2817 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2816) V2817 V2818)))))))))) (do (shen.unbindv V2709 V2817) Result))) false)))) (if (shen.pvar? V2708) (let B (shen.newpv V2817) (do (shen.bindv V2708 (cons B ()) V2817) (let Result (let Z (shen.newpv V2817) (let X&& (shen.newpv V2817) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (bind X&& (shen.placeholder) V2817 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2817) (shen.lazyderef X V2817) (shen.lazyderef Y V2817)) V2817 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2816) V2817 V2818)))))))))) (do (shen.unbindv V2708 V2817) Result)))) false))) (if (shen.pvar? V2707) (do (shen.bindv V2707 --> V2817) (let Result (let V2710 (shen.lazyderef (tl V2706) V2817) (if (cons? V2710) (let B (hd V2710) (let V2711 (shen.lazyderef (tl V2710) V2817) (if (= () V2711) (let Z (shen.newpv V2817) (let X&& (shen.newpv V2817) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (bind X&& (shen.placeholder) V2817 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2817) (shen.lazyderef X V2817) (shen.lazyderef Y V2817)) V2817 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2816) V2817 V2818)))))))))) (if (shen.pvar? V2711) (do (shen.bindv V2711 () V2817) (let Result (let Z (shen.newpv V2817) (let X&& (shen.newpv V2817) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (bind X&& (shen.placeholder) V2817 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2817) (shen.lazyderef X V2817) (shen.lazyderef Y V2817)) V2817 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2816) V2817 V2818)))))))))) (do (shen.unbindv V2711 V2817) Result))) false)))) (if (shen.pvar? V2710) (let B (shen.newpv V2817) (do (shen.bindv V2710 (cons B ()) V2817) (let Result (let Z (shen.newpv V2817) (let X&& (shen.newpv V2817) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (bind X&& (shen.placeholder) V2817 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2817) (shen.lazyderef X V2817) (shen.lazyderef Y V2817)) V2817 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2816) V2817 V2818)))))))))) (do (shen.unbindv V2710 V2817) Result)))) false))) (do (shen.unbindv V2707 V2817) Result))) false))) (if (shen.pvar? V2706) (let B (shen.newpv V2817) (do (shen.bindv V2706 (cons --> (cons B ())) V2817) (let Result (let Z (shen.newpv V2817) (let X&& (shen.newpv V2817) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (bind X&& (shen.placeholder) V2817 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2817) (shen.lazyderef X V2817) (shen.lazyderef Y V2817)) V2817 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2816) V2817 V2818)))))))))) (do (shen.unbindv V2706 V2817) Result)))) false)))) (if (shen.pvar? V2705) (let A (shen.newpv V2817) (let B (shen.newpv V2817) (do (shen.bindv V2705 (cons A (cons --> (cons B ()))) V2817) (let Result (let Z (shen.newpv V2817) (let X&& (shen.newpv V2817) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (bind X&& (shen.placeholder) V2817 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2817) (shen.lazyderef X V2817) (shen.lazyderef Y V2817)) V2817 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2816) V2817 V2818)))))))))) (do (shen.unbindv V2705 V2817) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2712 (shen.lazyderef V2814 V2817) (if (cons? V2712) (let V2713 (shen.lazyderef (hd V2712) V2817) (if (= let V2713) (let V2714 (shen.lazyderef (tl V2712) V2817) (if (cons? V2714) (let X (hd V2714) (let V2715 (shen.lazyderef (tl V2714) V2817) (if (cons? V2715) (let Y (hd V2715) (let V2716 (shen.lazyderef (tl V2715) V2817) (if (cons? V2716) (let Z (hd V2716) (let V2717 (shen.lazyderef (tl V2716) V2817) (if (= () V2717) (let W (shen.newpv V2817) (let X&& (shen.newpv V2817) (let B (shen.newpv V2817) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (shen.th* Y B V2816 V2817 (freeze (bind X&& (shen.placeholder) V2817 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2817) (shen.lazyderef X V2817) (shen.lazyderef Z V2817)) V2817 (freeze (shen.th* W V2815 (cons (cons X&& (cons : (cons B ()))) V2816) V2817 V2818))))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2718 (shen.lazyderef V2814 V2817) (if (cons? V2718) (let V2719 (shen.lazyderef (hd V2718) V2817) (if (= open V2719) (let V2720 (shen.lazyderef (tl V2718) V2817) (if (cons? V2720) (let V2721 (shen.lazyderef (hd V2720) V2817) (if (= file V2721) (let V2722 (shen.lazyderef (tl V2720) V2817) (if (cons? V2722) (let FileName (hd V2722) (let V2723 (shen.lazyderef (tl V2722) V2817) (if (cons? V2723) (let Direction2651 (hd V2723) (let V2724 (shen.lazyderef (tl V2723) V2817) (if (= () V2724) (let V2725 (shen.lazyderef V2815 V2817) (if (cons? V2725) (let V2726 (shen.lazyderef (hd V2725) V2817) (if (= stream V2726) (let V2727 (shen.lazyderef (tl V2725) V2817) (if (cons? V2727) (let Direction (hd V2727) (let V2728 (shen.lazyderef (tl V2727) V2817) (if (= () V2728) (do (shen.incinfs) (unify! Direction Direction2651 V2817 (freeze (cut Throwcontrol V2817 (freeze (shen.th* FileName string V2816 V2817 V2818)))))) (if (shen.pvar? V2728) (do (shen.bindv V2728 () V2817) (let Result (do (shen.incinfs) (unify! Direction Direction2651 V2817 (freeze (cut Throwcontrol V2817 (freeze (shen.th* FileName string V2816 V2817 V2818)))))) (do (shen.unbindv V2728 V2817) Result))) false)))) (if (shen.pvar? V2727) (let Direction (shen.newpv V2817) (do (shen.bindv V2727 (cons Direction ()) V2817) (let Result (do (shen.incinfs) (unify! Direction Direction2651 V2817 (freeze (cut Throwcontrol V2817 (freeze (shen.th* FileName string V2816 V2817 V2818)))))) (do (shen.unbindv V2727 V2817) Result)))) false))) (if (shen.pvar? V2726) (do (shen.bindv V2726 stream V2817) (let Result (let V2729 (shen.lazyderef (tl V2725) V2817) (if (cons? V2729) (let Direction (hd V2729) (let V2730 (shen.lazyderef (tl V2729) V2817) (if (= () V2730) (do (shen.incinfs) (unify! Direction Direction2651 V2817 (freeze (cut Throwcontrol V2817 (freeze (shen.th* FileName string V2816 V2817 V2818)))))) (if (shen.pvar? V2730) (do (shen.bindv V2730 () V2817) (let Result (do (shen.incinfs) (unify! Direction Direction2651 V2817 (freeze (cut Throwcontrol V2817 (freeze (shen.th* FileName string V2816 V2817 V2818)))))) (do (shen.unbindv V2730 V2817) Result))) false)))) (if (shen.pvar? V2729) (let Direction (shen.newpv V2817) (do (shen.bindv V2729 (cons Direction ()) V2817) (let Result (do (shen.incinfs) (unify! Direction Direction2651 V2817 (freeze (cut Throwcontrol V2817 (freeze (shen.th* FileName string V2816 V2817 V2818)))))) (do (shen.unbindv V2729 V2817) Result)))) false))) (do (shen.unbindv V2726 V2817) Result))) false))) (if (shen.pvar? V2725) (let Direction (shen.newpv V2817) (do (shen.bindv V2725 (cons stream (cons Direction ())) V2817) (let Result (do (shen.incinfs) (unify! Direction Direction2651 V2817 (freeze (cut Throwcontrol V2817 (freeze (shen.th* FileName string V2816 V2817 V2818)))))) (do (shen.unbindv V2725 V2817) Result)))) false))) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2731 (shen.lazyderef V2814 V2817) (if (cons? V2731) (let V2732 (shen.lazyderef (hd V2731) V2817) (if (= type V2732) (let V2733 (shen.lazyderef (tl V2731) V2817) (if (cons? V2733) (let X (hd V2733) (let V2734 (shen.lazyderef (tl V2733) V2817) (if (cons? V2734) (let A (hd V2734) (let V2735 (shen.lazyderef (tl V2734) V2817) (if (= () V2735) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (unify A V2815 V2817 (freeze (shen.th* X A V2816 V2817 V2818)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2736 (shen.lazyderef V2814 V2817) (if (cons? V2736) (let V2737 (shen.lazyderef (hd V2736) V2817) (if (= input+ V2737) (let V2738 (shen.lazyderef (tl V2736) V2817) (if (cons? V2738) (let V2739 (shen.lazyderef (hd V2738) V2817) (if (= : V2739) (let V2740 (shen.lazyderef (tl V2738) V2817) (if (cons? V2740) (let A (hd V2740) (let V2741 (shen.lazyderef (tl V2740) V2817) (if (= () V2741) (let C (shen.newpv V2817) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2817)) V2817 (freeze (unify V2815 C V2817 V2818))))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2742 (shen.lazyderef V2814 V2817) (if (cons? V2742) (let V2743 (shen.lazyderef (hd V2742) V2817) (if (= where V2743) (let V2744 (shen.lazyderef (tl V2742) V2817) (if (cons? V2744) (let P (hd V2744) (let V2745 (shen.lazyderef (tl V2744) V2817) (if (cons? V2745) (let X (hd V2745) (let V2746 (shen.lazyderef (tl V2745) V2817) (if (= () V2746) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (shen.th* P boolean V2816 V2817 (freeze (cut Throwcontrol V2817 (freeze (shen.th* X V2815 (cons (cons P (cons : (cons verified ()))) V2816) V2817 V2818)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2747 (shen.lazyderef V2814 V2817) (if (cons? V2747) (let V2748 (shen.lazyderef (hd V2747) V2817) (if (= set V2748) (let V2749 (shen.lazyderef (tl V2747) V2817) (if (cons? V2749) (let Var (hd V2749) (let V2750 (shen.lazyderef (tl V2749) V2817) (if (cons? V2750) (let Val (hd V2750) (let V2751 (shen.lazyderef (tl V2750) V2817) (if (= () V2751) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (shen.th* (cons value (cons Var ())) V2815 V2816 V2817 (freeze (shen.th* Val V2815 V2816 V2817 V2818)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2752 (shen.lazyderef V2814 V2817) (if (cons? V2752) (let V2753 (shen.lazyderef (hd V2752) V2817) (if (= shen.<-sem V2753) (let V2754 (shen.lazyderef (tl V2752) V2817) (if (cons? V2754) (let F (hd V2754) (let V2755 (shen.lazyderef (tl V2754) V2817) (if (= () V2755) (let A (shen.newpv V2817) (let F&& (shen.newpv V2817) (let B (shen.newpv V2817) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (shen.th* F (cons A (cons ==> (cons B ()))) V2816 V2817 (freeze (cut Throwcontrol V2817 (freeze (bind F&& (concat && (shen.lazyderef F V2817)) V2817 (freeze (cut Throwcontrol V2817 (freeze (shen.th* F&& V2815 (cons (cons F&& (cons : (cons B ()))) V2816) V2817 V2818))))))))))))))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2756 (shen.lazyderef V2814 V2817) (if (cons? V2756) (let V2757 (shen.lazyderef (hd V2756) V2817) (if (= fail V2757) (let V2758 (shen.lazyderef (tl V2756) V2817) (if (= () V2758) (let V2759 (shen.lazyderef V2815 V2817) (if (= symbol V2759) (do (shen.incinfs) (thaw V2818)) (if (shen.pvar? V2759) (do (shen.bindv V2759 symbol V2817) (let Result (do (shen.incinfs) (thaw V2818)) (do (shen.unbindv V2759 V2817) Result))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2817) (do (shen.incinfs) (shen.t*-hyps V2816 NewHyp V2817 (freeze (shen.th* V2814 V2815 NewHyp V2817 V2818))))) (if (= Case false) (let Case (let V2760 (shen.lazyderef V2814 V2817) (if (cons? V2760) (let V2761 (shen.lazyderef (hd V2760) V2817) (if (= define V2761) (let V2762 (shen.lazyderef (tl V2760) V2817) (if (cons? V2762) (let F (hd V2762) (let X (tl V2762) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (shen.t*-def (cons define (cons F X)) V2815 V2816 V2817 V2818)))))) false)) false)) false)) (if (= Case false) (let Case (let V2763 (shen.lazyderef V2814 V2817) (if (cons? V2763) (let V2764 (shen.lazyderef (hd V2763) V2817) (if (= defcc V2764) (let V2765 (shen.lazyderef (tl V2763) V2817) (if (cons? V2765) (let F (hd V2765) (let X (tl V2765) (do (shen.incinfs) (cut Throwcontrol V2817 (freeze (shen.t*-defcc (cons defcc (cons F X)) V2815 V2816 V2817 V2818)))))) false)) false)) false)) (if (= Case false) (let Case (let V2766 (shen.lazyderef V2814 V2817) (if (cons? V2766) (let V2767 (shen.lazyderef (hd V2766) V2817) (if (= shen.process-datatype V2767) (let V2768 (shen.lazyderef V2815 V2817) (if (= symbol V2768) (do (shen.incinfs) (thaw V2818)) (if (shen.pvar? V2768) (do (shen.bindv V2768 symbol V2817) (let Result (do (shen.incinfs) (thaw V2818)) (do (shen.unbindv V2768 V2817) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2769 (shen.lazyderef V2814 V2817) (if (cons? V2769) (let V2770 (shen.lazyderef (hd V2769) V2817) (if (= shen.synonyms-help V2770) (let V2771 (shen.lazyderef V2815 V2817) (if (= symbol V2771) (do (shen.incinfs) (thaw V2818)) (if (shen.pvar? V2771) (do (shen.bindv V2771 symbol V2817) (let Result (do (shen.incinfs) (thaw V2818)) (do (shen.unbindv V2771 V2817) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2817) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2817 (freeze (shen.udefs* (cons V2814 (cons : (cons V2815 ()))) V2816 Datatypes V2817 V2818))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2819 V2820 V2821 V2822) (let Case (let V2566 (shen.lazyderef V2819 V2821) (if (cons? V2566) (let V2567 (shen.lazyderef (hd V2566) V2821) (if (cons? V2567) (let V2568 (shen.lazyderef (hd V2567) V2821) (if (cons? V2568) (let V2569 (shen.lazyderef (hd V2568) V2821) (if (= cons V2569) (let V2570 (shen.lazyderef (tl V2568) V2821) (if (cons? V2570) (let X (hd V2570) (let V2571 (shen.lazyderef (tl V2570) V2821) (if (cons? V2571) (let Y (hd V2571) (let V2572 (shen.lazyderef (tl V2571) V2821) (if (= () V2572) (let V2573 (shen.lazyderef (tl V2567) V2821) (if (cons? V2573) (let V2574 (shen.lazyderef (hd V2573) V2821) (if (= : V2574) (let V2575 (shen.lazyderef (tl V2573) V2821) (if (cons? V2575) (let V2576 (shen.lazyderef (hd V2575) V2821) (if (cons? V2576) (let V2577 (shen.lazyderef (hd V2576) V2821) (if (= list V2577) (let V2578 (shen.lazyderef (tl V2576) V2821) (if (cons? V2578) (let A (hd V2578) (let V2579 (shen.lazyderef (tl V2578) V2821) (if (= () V2579) (let V2580 (shen.lazyderef (tl V2575) V2821) (if (= () V2580) (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2580) (do (shen.bindv V2580 () V2821) (let Result (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2580 V2821) Result))) false))) (if (shen.pvar? V2579) (do (shen.bindv V2579 () V2821) (let Result (let V2581 (shen.lazyderef (tl V2575) V2821) (if (= () V2581) (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2581) (do (shen.bindv V2581 () V2821) (let Result (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2581 V2821) Result))) false))) (do (shen.unbindv V2579 V2821) Result))) false)))) (if (shen.pvar? V2578) (let A (shen.newpv V2821) (do (shen.bindv V2578 (cons A ()) V2821) (let Result (let V2582 (shen.lazyderef (tl V2575) V2821) (if (= () V2582) (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2582) (do (shen.bindv V2582 () V2821) (let Result (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2582 V2821) Result))) false))) (do (shen.unbindv V2578 V2821) Result)))) false))) (if (shen.pvar? V2577) (do (shen.bindv V2577 list V2821) (let Result (let V2583 (shen.lazyderef (tl V2576) V2821) (if (cons? V2583) (let A (hd V2583) (let V2584 (shen.lazyderef (tl V2583) V2821) (if (= () V2584) (let V2585 (shen.lazyderef (tl V2575) V2821) (if (= () V2585) (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2585) (do (shen.bindv V2585 () V2821) (let Result (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2585 V2821) Result))) false))) (if (shen.pvar? V2584) (do (shen.bindv V2584 () V2821) (let Result (let V2586 (shen.lazyderef (tl V2575) V2821) (if (= () V2586) (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2586) (do (shen.bindv V2586 () V2821) (let Result (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2586 V2821) Result))) false))) (do (shen.unbindv V2584 V2821) Result))) false)))) (if (shen.pvar? V2583) (let A (shen.newpv V2821) (do (shen.bindv V2583 (cons A ()) V2821) (let Result (let V2587 (shen.lazyderef (tl V2575) V2821) (if (= () V2587) (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2587) (do (shen.bindv V2587 () V2821) (let Result (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2587 V2821) Result))) false))) (do (shen.unbindv V2583 V2821) Result)))) false))) (do (shen.unbindv V2577 V2821) Result))) false))) (if (shen.pvar? V2576) (let A (shen.newpv V2821) (do (shen.bindv V2576 (cons list (cons A ())) V2821) (let Result (let V2588 (shen.lazyderef (tl V2575) V2821) (if (= () V2588) (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2588) (do (shen.bindv V2588 () V2821) (let Result (let Hyp (tl V2566) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons list (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2588 V2821) Result))) false))) (do (shen.unbindv V2576 V2821) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2589 (shen.lazyderef V2819 V2821) (if (cons? V2589) (let V2590 (shen.lazyderef (hd V2589) V2821) (if (cons? V2590) (let V2591 (shen.lazyderef (hd V2590) V2821) (if (cons? V2591) (let V2592 (shen.lazyderef (hd V2591) V2821) (if (= @p V2592) (let V2593 (shen.lazyderef (tl V2591) V2821) (if (cons? V2593) (let X (hd V2593) (let V2594 (shen.lazyderef (tl V2593) V2821) (if (cons? V2594) (let Y (hd V2594) (let V2595 (shen.lazyderef (tl V2594) V2821) (if (= () V2595) (let V2596 (shen.lazyderef (tl V2590) V2821) (if (cons? V2596) (let V2597 (shen.lazyderef (hd V2596) V2821) (if (= : V2597) (let V2598 (shen.lazyderef (tl V2596) V2821) (if (cons? V2598) (let V2599 (shen.lazyderef (hd V2598) V2821) (if (cons? V2599) (let A (hd V2599) (let V2600 (shen.lazyderef (tl V2599) V2821) (if (cons? V2600) (let V2601 (shen.lazyderef (hd V2600) V2821) (if (= * V2601) (let V2602 (shen.lazyderef (tl V2600) V2821) (if (cons? V2602) (let B (hd V2602) (let V2603 (shen.lazyderef (tl V2602) V2821) (if (= () V2603) (let V2604 (shen.lazyderef (tl V2598) V2821) (if (= () V2604) (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2604) (do (shen.bindv V2604 () V2821) (let Result (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2604 V2821) Result))) false))) (if (shen.pvar? V2603) (do (shen.bindv V2603 () V2821) (let Result (let V2605 (shen.lazyderef (tl V2598) V2821) (if (= () V2605) (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2605) (do (shen.bindv V2605 () V2821) (let Result (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2605 V2821) Result))) false))) (do (shen.unbindv V2603 V2821) Result))) false)))) (if (shen.pvar? V2602) (let B (shen.newpv V2821) (do (shen.bindv V2602 (cons B ()) V2821) (let Result (let V2606 (shen.lazyderef (tl V2598) V2821) (if (= () V2606) (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2606) (do (shen.bindv V2606 () V2821) (let Result (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2606 V2821) Result))) false))) (do (shen.unbindv V2602 V2821) Result)))) false))) (if (shen.pvar? V2601) (do (shen.bindv V2601 * V2821) (let Result (let V2607 (shen.lazyderef (tl V2600) V2821) (if (cons? V2607) (let B (hd V2607) (let V2608 (shen.lazyderef (tl V2607) V2821) (if (= () V2608) (let V2609 (shen.lazyderef (tl V2598) V2821) (if (= () V2609) (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2609) (do (shen.bindv V2609 () V2821) (let Result (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2609 V2821) Result))) false))) (if (shen.pvar? V2608) (do (shen.bindv V2608 () V2821) (let Result (let V2610 (shen.lazyderef (tl V2598) V2821) (if (= () V2610) (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2610) (do (shen.bindv V2610 () V2821) (let Result (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2610 V2821) Result))) false))) (do (shen.unbindv V2608 V2821) Result))) false)))) (if (shen.pvar? V2607) (let B (shen.newpv V2821) (do (shen.bindv V2607 (cons B ()) V2821) (let Result (let V2611 (shen.lazyderef (tl V2598) V2821) (if (= () V2611) (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2611) (do (shen.bindv V2611 () V2821) (let Result (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2611 V2821) Result))) false))) (do (shen.unbindv V2607 V2821) Result)))) false))) (do (shen.unbindv V2601 V2821) Result))) false))) (if (shen.pvar? V2600) (let B (shen.newpv V2821) (do (shen.bindv V2600 (cons * (cons B ())) V2821) (let Result (let V2612 (shen.lazyderef (tl V2598) V2821) (if (= () V2612) (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2612) (do (shen.bindv V2612 () V2821) (let Result (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2612 V2821) Result))) false))) (do (shen.unbindv V2600 V2821) Result)))) false)))) (if (shen.pvar? V2599) (let A (shen.newpv V2821) (let B (shen.newpv V2821) (do (shen.bindv V2599 (cons A (cons * (cons B ()))) V2821) (let Result (let V2613 (shen.lazyderef (tl V2598) V2821) (if (= () V2613) (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2613) (do (shen.bindv V2613 () V2821) (let Result (let Hyp (tl V2589) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (shen.lazyderef B V2821) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2613 V2821) Result))) false))) (do (shen.unbindv V2599 V2821) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2614 (shen.lazyderef V2819 V2821) (if (cons? V2614) (let V2615 (shen.lazyderef (hd V2614) V2821) (if (cons? V2615) (let V2616 (shen.lazyderef (hd V2615) V2821) (if (cons? V2616) (let V2617 (shen.lazyderef (hd V2616) V2821) (if (= @v V2617) (let V2618 (shen.lazyderef (tl V2616) V2821) (if (cons? V2618) (let X (hd V2618) (let V2619 (shen.lazyderef (tl V2618) V2821) (if (cons? V2619) (let Y (hd V2619) (let V2620 (shen.lazyderef (tl V2619) V2821) (if (= () V2620) (let V2621 (shen.lazyderef (tl V2615) V2821) (if (cons? V2621) (let V2622 (shen.lazyderef (hd V2621) V2821) (if (= : V2622) (let V2623 (shen.lazyderef (tl V2621) V2821) (if (cons? V2623) (let V2624 (shen.lazyderef (hd V2623) V2821) (if (cons? V2624) (let V2625 (shen.lazyderef (hd V2624) V2821) (if (= vector V2625) (let V2626 (shen.lazyderef (tl V2624) V2821) (if (cons? V2626) (let A (hd V2626) (let V2627 (shen.lazyderef (tl V2626) V2821) (if (= () V2627) (let V2628 (shen.lazyderef (tl V2623) V2821) (if (= () V2628) (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2628) (do (shen.bindv V2628 () V2821) (let Result (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2628 V2821) Result))) false))) (if (shen.pvar? V2627) (do (shen.bindv V2627 () V2821) (let Result (let V2629 (shen.lazyderef (tl V2623) V2821) (if (= () V2629) (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2629) (do (shen.bindv V2629 () V2821) (let Result (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2629 V2821) Result))) false))) (do (shen.unbindv V2627 V2821) Result))) false)))) (if (shen.pvar? V2626) (let A (shen.newpv V2821) (do (shen.bindv V2626 (cons A ()) V2821) (let Result (let V2630 (shen.lazyderef (tl V2623) V2821) (if (= () V2630) (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2630) (do (shen.bindv V2630 () V2821) (let Result (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2630 V2821) Result))) false))) (do (shen.unbindv V2626 V2821) Result)))) false))) (if (shen.pvar? V2625) (do (shen.bindv V2625 vector V2821) (let Result (let V2631 (shen.lazyderef (tl V2624) V2821) (if (cons? V2631) (let A (hd V2631) (let V2632 (shen.lazyderef (tl V2631) V2821) (if (= () V2632) (let V2633 (shen.lazyderef (tl V2623) V2821) (if (= () V2633) (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2633) (do (shen.bindv V2633 () V2821) (let Result (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2633 V2821) Result))) false))) (if (shen.pvar? V2632) (do (shen.bindv V2632 () V2821) (let Result (let V2634 (shen.lazyderef (tl V2623) V2821) (if (= () V2634) (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2634) (do (shen.bindv V2634 () V2821) (let Result (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2634 V2821) Result))) false))) (do (shen.unbindv V2632 V2821) Result))) false)))) (if (shen.pvar? V2631) (let A (shen.newpv V2821) (do (shen.bindv V2631 (cons A ()) V2821) (let Result (let V2635 (shen.lazyderef (tl V2623) V2821) (if (= () V2635) (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2635) (do (shen.bindv V2635 () V2821) (let Result (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2635 V2821) Result))) false))) (do (shen.unbindv V2631 V2821) Result)))) false))) (do (shen.unbindv V2625 V2821) Result))) false))) (if (shen.pvar? V2624) (let A (shen.newpv V2821) (do (shen.bindv V2624 (cons vector (cons A ())) V2821) (let Result (let V2636 (shen.lazyderef (tl V2623) V2821) (if (= () V2636) (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2636) (do (shen.bindv V2636 () V2821) (let Result (let Hyp (tl V2614) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons (shen.lazyderef A V2821) ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons (cons vector (cons (shen.lazyderef A V2821) ())) ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2636 V2821) Result))) false))) (do (shen.unbindv V2624 V2821) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2637 (shen.lazyderef V2819 V2821) (if (cons? V2637) (let V2638 (shen.lazyderef (hd V2637) V2821) (if (cons? V2638) (let V2639 (shen.lazyderef (hd V2638) V2821) (if (cons? V2639) (let V2640 (shen.lazyderef (hd V2639) V2821) (if (= @s V2640) (let V2641 (shen.lazyderef (tl V2639) V2821) (if (cons? V2641) (let X (hd V2641) (let V2642 (shen.lazyderef (tl V2641) V2821) (if (cons? V2642) (let Y (hd V2642) (let V2643 (shen.lazyderef (tl V2642) V2821) (if (= () V2643) (let V2644 (shen.lazyderef (tl V2638) V2821) (if (cons? V2644) (let V2645 (shen.lazyderef (hd V2644) V2821) (if (= : V2645) (let V2646 (shen.lazyderef (tl V2644) V2821) (if (cons? V2646) (let V2647 (shen.lazyderef (hd V2646) V2821) (if (= string V2647) (let V2648 (shen.lazyderef (tl V2646) V2821) (if (= () V2648) (let Hyp (tl V2637) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons string ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2648) (do (shen.bindv V2648 () V2821) (let Result (let Hyp (tl V2637) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons string ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2648 V2821) Result))) false))) (if (shen.pvar? V2647) (do (shen.bindv V2647 string V2821) (let Result (let V2649 (shen.lazyderef (tl V2646) V2821) (if (= () V2649) (let Hyp (tl V2637) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons string ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (if (shen.pvar? V2649) (do (shen.bindv V2649 () V2821) (let Result (let Hyp (tl V2637) (do (shen.incinfs) (bind V2820 (cons (cons (shen.lazyderef X V2821) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2821) (cons : (cons string ()))) (shen.lazyderef Hyp V2821))) V2821 V2822))) (do (shen.unbindv V2649 V2821) Result))) false))) (do (shen.unbindv V2647 V2821) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2650 (shen.lazyderef V2819 V2821) (if (cons? V2650) (let X (hd V2650) (let Hyp (tl V2650) (let NewHyps (shen.newpv V2821) (do (shen.incinfs) (bind V2820 (cons (shen.lazyderef X V2821) (shen.lazyderef NewHyps V2821)) V2821 (freeze (shen.t*-hyps Hyp NewHyps V2821 V2822))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2835 V2836 V2837 V2838) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2835 V2837)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2836 V2837) 1) (do (pr "
> " (stoutput)) (do (shen.pause-for-user (value *language*)) (thaw V2838))))))))) (true (thaw V2838))))

(defun shen.line () (let Infs (inferences) (pr (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2839) (cond ((and (cons? V2839) (and (cons? (tl V2839)) (and (= : (hd (tl V2839))) (and (cons? (tl (tl V2839))) (= () (tl (tl (tl V2839)))))))) (pr (shen.app (hd V2839) (cn " : " (shen.app (hd (tl (tl V2839))) "" shen.r)) shen.r) (stoutput))) (true (pr (shen.app V2839 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2842 V2843) (cond ((= () V2842) shen.skip) ((cons? V2842) (do (pr (shen.app V2843 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2842)) (do (nl 1) (shen.show-assumptions (tl V2842) (+ V2843 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user (V2848) (cond ((= "Common Lisp" V2848) (let I (FORMAT () "~C" (READ-CHAR)) (if (= I "a") (simple-error "input aborted
") (nl 1)))) (true (let I (shen.read-char) (if (= I "a") (simple-error "input aborted
") (nl 1))))))

(defun shen.read-char () (shen.read-char-h (read-byte (stinput)) 0))

(defun shen.read-char-h (V2851 V2852) (cond ((and (= -1 V2851) (= 0 V2852)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 0 V2852) (shen.read-char-h (read-byte (stinput)) 0)) ((and (= -1 V2851) (= 1 V2852)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 1 V2852) (n->string V2851)) (true (shen.sys-error shen.read-char-h))))

(defun shen.typedf? (V2853) (element? V2853 (value shen.*signedfuncs*)))

(defun shen.sigf (V2854) (concat shen.type-signature-of- V2854))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2855 V2856 V2857 V2858) (let Case (let V2553 (shen.lazyderef V2856 V2857) (if (= number V2553) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2855 V2857)) V2857 V2858)) (if (shen.pvar? V2553) (do (shen.bindv V2553 number V2857) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2855 V2857)) V2857 V2858)) (do (shen.unbindv V2553 V2857) Result))) false))) (if (= Case false) (let Case (let V2554 (shen.lazyderef V2856 V2857) (if (= boolean V2554) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2855 V2857)) V2857 V2858)) (if (shen.pvar? V2554) (do (shen.bindv V2554 boolean V2857) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2855 V2857)) V2857 V2858)) (do (shen.unbindv V2554 V2857) Result))) false))) (if (= Case false) (let Case (let V2555 (shen.lazyderef V2856 V2857) (if (= string V2555) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2855 V2857)) V2857 V2858)) (if (shen.pvar? V2555) (do (shen.bindv V2555 string V2857) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2855 V2857)) V2857 V2858)) (do (shen.unbindv V2555 V2857) Result))) false))) (if (= Case false) (let Case (let V2556 (shen.lazyderef V2856 V2857) (if (= symbol V2556) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2855 V2857)) V2857 (freeze (fwhen (not (shen.placeholder? (shen.lazyderef V2855 V2857))) V2857 V2858)))) (if (shen.pvar? V2556) (do (shen.bindv V2556 symbol V2857) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2855 V2857)) V2857 (freeze (fwhen (not (shen.placeholder? (shen.lazyderef V2855 V2857))) V2857 V2858)))) (do (shen.unbindv V2556 V2857) Result))) false))) (if (= Case false) (let V2557 (shen.lazyderef V2855 V2857) (if (= () V2557) (let V2558 (shen.lazyderef V2856 V2857) (if (cons? V2558) (let V2559 (shen.lazyderef (hd V2558) V2857) (if (= list V2559) (let V2560 (shen.lazyderef (tl V2558) V2857) (if (cons? V2560) (let A (hd V2560) (let V2561 (shen.lazyderef (tl V2560) V2857) (if (= () V2561) (do (shen.incinfs) (thaw V2858)) (if (shen.pvar? V2561) (do (shen.bindv V2561 () V2857) (let Result (do (shen.incinfs) (thaw V2858)) (do (shen.unbindv V2561 V2857) Result))) false)))) (if (shen.pvar? V2560) (let A (shen.newpv V2857) (do (shen.bindv V2560 (cons A ()) V2857) (let Result (do (shen.incinfs) (thaw V2858)) (do (shen.unbindv V2560 V2857) Result)))) false))) (if (shen.pvar? V2559) (do (shen.bindv V2559 list V2857) (let Result (let V2562 (shen.lazyderef (tl V2558) V2857) (if (cons? V2562) (let A (hd V2562) (let V2563 (shen.lazyderef (tl V2562) V2857) (if (= () V2563) (do (shen.incinfs) (thaw V2858)) (if (shen.pvar? V2563) (do (shen.bindv V2563 () V2857) (let Result (do (shen.incinfs) (thaw V2858)) (do (shen.unbindv V2563 V2857) Result))) false)))) (if (shen.pvar? V2562) (let A (shen.newpv V2857) (do (shen.bindv V2562 (cons A ()) V2857) (let Result (do (shen.incinfs) (thaw V2858)) (do (shen.unbindv V2562 V2857) Result)))) false))) (do (shen.unbindv V2559 V2857) Result))) false))) (if (shen.pvar? V2558) (let A (shen.newpv V2857) (do (shen.bindv V2558 (cons list (cons A ())) V2857) (let Result (do (shen.incinfs) (thaw V2858)) (do (shen.unbindv V2558 V2857) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.placeholder? (V2859) (and (symbol? V2859) (shen.placeholder-help? (str V2859))))

(defun shen.placeholder-help? (V2866) (cond ((and (shen.+string? V2866) (and (= "&" (pos V2866 0)) (and (shen.+string? (tlstr V2866)) (= "&" (pos (tlstr V2866) 0))))) true) (true false)))

(defun shen.by_hypothesis (V2867 V2868 V2869 V2870 V2871) (let Case (let V2544 (shen.lazyderef V2869 V2870) (if (cons? V2544) (let V2545 (shen.lazyderef (hd V2544) V2870) (if (cons? V2545) (let Y (hd V2545) (let V2546 (shen.lazyderef (tl V2545) V2870) (if (cons? V2546) (let V2547 (shen.lazyderef (hd V2546) V2870) (if (= : V2547) (let V2548 (shen.lazyderef (tl V2546) V2870) (if (cons? V2548) (let B (hd V2548) (let V2549 (shen.lazyderef (tl V2548) V2870) (if (= () V2549) (do (shen.incinfs) (identical V2867 Y V2870 (freeze (unify! V2868 B V2870 V2871)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2550 (shen.lazyderef V2869 V2870) (if (cons? V2550) (let Hyp (tl V2550) (do (shen.incinfs) (shen.by_hypothesis V2867 V2868 Hyp V2870 V2871))) false)) Case)))

(defun shen.t*-def (V2872 V2873 V2874 V2875 V2876) (let V2538 (shen.lazyderef V2872 V2875) (if (cons? V2538) (let V2539 (shen.lazyderef (hd V2538) V2875) (if (= define V2539) (let V2540 (shen.lazyderef (tl V2538) V2875) (if (cons? V2540) (let F (hd V2540) (let X (tl V2540) (let E (shen.newpv V2875) (do (shen.incinfs) (shen.t*-defh (compile shen.<sig+rules> X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2873 V2874 V2875 V2876))))) false)) false)) false)))

(defun shen.t*-defh (V2877 V2878 V2879 V2880 V2881 V2882) (let V2534 (shen.lazyderef V2877 V2881) (if (cons? V2534) (let Sig (hd V2534) (let Rules (tl V2534) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue Sig) V2878 V2879 V2880 Rules V2881 V2882)))) false)))

(defun shen.t*-defhh (V2883 V2884 V2885 V2886 V2887 V2888 V2889 V2890) (do (shen.incinfs) (shen.t*-rules V2888 V2884 1 V2885 (cons (cons V2885 (cons : (cons V2884 ()))) V2887) V2889 (freeze (shen.memo V2885 V2883 V2886 V2889 V2890)))))

(defun shen.memo (V2891 V2892 V2893 V2894 V2895) (let Jnk (shen.newpv V2894) (do (shen.incinfs) (unify! V2893 V2892 V2894 (freeze (bind Jnk (declare (shen.lazyderef V2891 V2894) (shen.lazyderef V2893 V2894)) V2894 V2895))))))

(defun shen.<sig+rules> (V2900) (let Result (let Parse_shen.<signature> (shen.<signature> V2900) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.ue (V2901) (cond ((cons? V2901) (map shen.ue V2901)) ((variable? V2901) (concat && V2901)) (true V2901)))

(defun shen.t*-rules (V2902 V2903 V2904 V2905 V2906 V2907 V2908) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2509 (shen.lazyderef V2902 V2907) (if (= () V2509) (do (shen.incinfs) (thaw V2908)) false)) (if (= Case false) (let Case (let V2510 (shen.lazyderef V2902 V2907) (if (cons? V2510) (let V2511 (shen.lazyderef (hd V2510) V2907) (if (cons? V2511) (let V2512 (shen.lazyderef (hd V2511) V2907) (if (= () V2512) (let V2513 (shen.lazyderef (tl V2511) V2907) (if (cons? V2513) (let Action (hd V2513) (let V2514 (shen.lazyderef (tl V2513) V2907) (if (= () V2514) (let Rules (tl V2510) (let V2515 (shen.lazyderef V2903 V2907) (if (cons? V2515) (let V2516 (shen.lazyderef (hd V2515) V2907) (if (= --> V2516) (let V2517 (shen.lazyderef (tl V2515) V2907) (if (cons? V2517) (let A (hd V2517) (let V2518 (shen.lazyderef (tl V2517) V2907) (if (= () V2518) (do (shen.incinfs) (shen.t*-rule (cons () (cons (shen.ue Action) ())) A V2906 V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-rules Rules A (+ V2904 1) V2905 V2906 V2907 V2908)))))) false))) false)) false)) false))) false))) false)) false)) false)) false)) (if (= Case false) (let Case (let V2519 (shen.lazyderef V2902 V2907) (if (cons? V2519) (let Rule (hd V2519) (let Rules (tl V2519) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2903 V2906 V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-rules Rules V2903 (+ V2904 1) V2905 V2906 V2907 V2908)))))))) false)) (if (= Case false) (let Err (shen.newpv V2907) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2904 V2907) (cn " of " (shen.app (shen.lazyderef V2905 V2907) "" shen.a)) shen.a))) V2907 V2908))) Case)) Case)) Case)))))

(defun shen.t*-rule (V2909 V2910 V2911 V2912 V2913) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2491 (shen.lazyderef V2909 V2912) (if (cons? V2491) (let V2492 (shen.lazyderef (hd V2491) V2912) (if (= () V2492) (let V2493 (shen.lazyderef (tl V2491) V2912) (if (cons? V2493) (let Action (hd V2493) (let V2494 (shen.lazyderef (tl V2493) V2912) (if (= () V2494) (do (shen.incinfs) (cut Throwcontrol V2912 (freeze (shen.t*-action (shen.curry Action) V2910 V2911 V2912 V2913)))) false))) false)) false)) false)) (if (= Case false) (let V2495 (shen.lazyderef V2909 V2912) (if (cons? V2495) (let V2496 (shen.lazyderef (hd V2495) V2912) (if (cons? V2496) (let Pattern (hd V2496) (let Patterns (tl V2496) (let V2497 (shen.lazyderef (tl V2495) V2912) (if (cons? V2497) (let Action (hd V2497) (let V2498 (shen.lazyderef (tl V2497) V2912) (if (= () V2498) (let V2499 (shen.lazyderef V2910 V2912) (if (cons? V2499) (let A (hd V2499) (let V2500 (shen.lazyderef (tl V2499) V2912) (if (cons? V2500) (let V2501 (shen.lazyderef (hd V2500) V2912) (if (= --> V2501) (let V2502 (shen.lazyderef (tl V2500) V2912) (if (cons? V2502) (let B (hd V2502) (let V2503 (shen.lazyderef (tl V2502) V2912) (if (= () V2503) (do (shen.incinfs) (shen.t*-pattern Pattern A V2912 (freeze (cut Throwcontrol V2912 (freeze (shen.t*-rule (cons Patterns (cons Action ())) B (cons (cons Pattern (cons : (cons A ()))) V2911) V2912 V2913)))))) false))) false)) false)) false))) false)) false))) false)))) false)) false)) Case)))))

(defun shen.t*-action (V2914 V2915 V2916 V2917 V2918) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2468 (shen.lazyderef V2914 V2917) (if (cons? V2468) (let V2469 (shen.lazyderef (hd V2468) V2917) (if (= where V2469) (let V2470 (shen.lazyderef (tl V2468) V2917) (if (cons? V2470) (let P (hd V2470) (let V2471 (shen.lazyderef (tl V2470) V2917) (if (cons? V2471) (let Action (hd V2471) (let V2472 (shen.lazyderef (tl V2471) V2917) (if (= () V2472) (do (shen.incinfs) (cut Throwcontrol V2917 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2916 V2917 (freeze (cut Throwcontrol V2917 (freeze (shen.t*-action Action V2915 (cons (cons P (cons : (cons verified ()))) V2916) V2917 V2918)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2473 (shen.lazyderef V2914 V2917) (if (cons? V2473) (let V2474 (shen.lazyderef (hd V2473) V2917) (if (= shen.choicepoint! V2474) (let V2475 (shen.lazyderef (tl V2473) V2917) (if (cons? V2475) (let V2476 (shen.lazyderef (hd V2475) V2917) (if (cons? V2476) (let V2477 (shen.lazyderef (hd V2476) V2917) (if (cons? V2477) (let V2478 (shen.lazyderef (hd V2477) V2917) (if (= fail-if V2478) (let V2479 (shen.lazyderef (tl V2477) V2917) (if (cons? V2479) (let F (hd V2479) (let V2480 (shen.lazyderef (tl V2479) V2917) (if (= () V2480) (let V2481 (shen.lazyderef (tl V2476) V2917) (if (cons? V2481) (let Action (hd V2481) (let V2482 (shen.lazyderef (tl V2481) V2917) (if (= () V2482) (let V2483 (shen.lazyderef (tl V2475) V2917) (if (= () V2483) (do (shen.incinfs) (cut Throwcontrol V2917 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2915 V2916 V2917 V2918)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2484 (shen.lazyderef V2914 V2917) (if (cons? V2484) (let V2485 (shen.lazyderef (hd V2484) V2917) (if (= shen.choicepoint! V2485) (let V2486 (shen.lazyderef (tl V2484) V2917) (if (cons? V2486) (let Action (hd V2486) (let V2487 (shen.lazyderef (tl V2486) V2917) (if (= () V2487) (do (shen.incinfs) (cut Throwcontrol V2917 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2915 V2916 V2917 V2918)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2914 (cons : (cons V2915 ()))) V2916 V2917 V2918)) Case)) Case)) Case)))))

(defun shen.t*-pattern (V2919 V2920 V2921 V2922) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Hyp (shen.newpv V2921) (do (shen.incinfs) (shen.tms->hyp (shen.ues V2919) Hyp V2921 (freeze (cut Throwcontrol V2921 (freeze (shen.t* (cons V2919 (cons : (cons V2920 ()))) Hyp V2921 V2922))))))))))

(defun shen.ues (V2927) (cond ((shen.ue? V2927) (cons V2927 ())) ((cons? V2927) (union (shen.ues (hd V2927)) (shen.ues (tl V2927)))) (true ())))

(defun shen.ue? (V2928) (and (symbol? V2928) (shen.ue-h? (str V2928))))

(defun shen.ue-h? (V2935) (cond ((and (shen.+string? V2935) (and (= "&" (pos V2935 0)) (and (shen.+string? (tlstr V2935)) (= "&" (pos (tlstr V2935) 0))))) true) (true false)))

(defun shen.tms->hyp (V2936 V2937 V2938 V2939) (let Case (let V2452 (shen.lazyderef V2936 V2938) (if (= () V2452) (let V2453 (shen.lazyderef V2937 V2938) (if (= () V2453) (do (shen.incinfs) (thaw V2939)) (if (shen.pvar? V2453) (do (shen.bindv V2453 () V2938) (let Result (do (shen.incinfs) (thaw V2939)) (do (shen.unbindv V2453 V2938) Result))) false))) false)) (if (= Case false) (let V2454 (shen.lazyderef V2936 V2938) (if (cons? V2454) (let Tm2449 (hd V2454) (let Tms (tl V2454) (let V2455 (shen.lazyderef V2937 V2938) (if (cons? V2455) (let V2456 (shen.lazyderef (hd V2455) V2938) (if (cons? V2456) (let Tm (hd V2456) (let V2457 (shen.lazyderef (tl V2456) V2938) (if (cons? V2457) (let V2458 (shen.lazyderef (hd V2457) V2938) (if (= : V2458) (let V2459 (shen.lazyderef (tl V2457) V2938) (if (cons? V2459) (let A (hd V2459) (let V2460 (shen.lazyderef (tl V2459) V2938) (if (= () V2460) (let Hyp (tl V2455) (do (shen.incinfs) (unify! Tm Tm2449 V2938 (freeze (shen.tms->hyp Tms Hyp V2938 V2939))))) (if (shen.pvar? V2460) (do (shen.bindv V2460 () V2938) (let Result (let Hyp (tl V2455) (do (shen.incinfs) (unify! Tm Tm2449 V2938 (freeze (shen.tms->hyp Tms Hyp V2938 V2939))))) (do (shen.unbindv V2460 V2938) Result))) false)))) (if (shen.pvar? V2459) (let A (shen.newpv V2938) (do (shen.bindv V2459 (cons A ()) V2938) (let Result (let Hyp (tl V2455) (do (shen.incinfs) (unify! Tm Tm2449 V2938 (freeze (shen.tms->hyp Tms Hyp V2938 V2939))))) (do (shen.unbindv V2459 V2938) Result)))) false))) (if (shen.pvar? V2458) (do (shen.bindv V2458 : V2938) (let Result (let V2461 (shen.lazyderef (tl V2457) V2938) (if (cons? V2461) (let A (hd V2461) (let V2462 (shen.lazyderef (tl V2461) V2938) (if (= () V2462) (let Hyp (tl V2455) (do (shen.incinfs) (unify! Tm Tm2449 V2938 (freeze (shen.tms->hyp Tms Hyp V2938 V2939))))) (if (shen.pvar? V2462) (do (shen.bindv V2462 () V2938) (let Result (let Hyp (tl V2455) (do (shen.incinfs) (unify! Tm Tm2449 V2938 (freeze (shen.tms->hyp Tms Hyp V2938 V2939))))) (do (shen.unbindv V2462 V2938) Result))) false)))) (if (shen.pvar? V2461) (let A (shen.newpv V2938) (do (shen.bindv V2461 (cons A ()) V2938) (let Result (let Hyp (tl V2455) (do (shen.incinfs) (unify! Tm Tm2449 V2938 (freeze (shen.tms->hyp Tms Hyp V2938 V2939))))) (do (shen.unbindv V2461 V2938) Result)))) false))) (do (shen.unbindv V2458 V2938) Result))) false))) (if (shen.pvar? V2457) (let A (shen.newpv V2938) (do (shen.bindv V2457 (cons : (cons A ())) V2938) (let Result (let Hyp (tl V2455) (do (shen.incinfs) (unify! Tm Tm2449 V2938 (freeze (shen.tms->hyp Tms Hyp V2938 V2939))))) (do (shen.unbindv V2457 V2938) Result)))) false)))) (if (shen.pvar? V2456) (let Tm (shen.newpv V2938) (let A (shen.newpv V2938) (do (shen.bindv V2456 (cons Tm (cons : (cons A ()))) V2938) (let Result (let Hyp (tl V2455) (do (shen.incinfs) (unify! Tm Tm2449 V2938 (freeze (shen.tms->hyp Tms Hyp V2938 V2939))))) (do (shen.unbindv V2456 V2938) Result))))) false))) (if (shen.pvar? V2455) (let Tm (shen.newpv V2938) (let A (shen.newpv V2938) (let Hyp (shen.newpv V2938) (do (shen.bindv V2455 (cons (cons Tm (cons : (cons A ()))) Hyp) V2938) (let Result (do (shen.incinfs) (unify! Tm Tm2449 V2938 (freeze (shen.tms->hyp Tms Hyp V2938 V2939)))) (do (shen.unbindv V2455 V2938) Result)))))) false))))) false)) Case)))

(defun findall (V2940 V2941 V2942 V2943 V2944) (let B (shen.newpv V2943) (let A (shen.newpv V2943) (do (shen.incinfs) (bind A (gensym shen.a) V2943 (freeze (bind B (set (shen.lazyderef A V2943) ()) V2943 (freeze (shen.findallhelp V2940 V2941 V2942 A V2943 V2944)))))))))

(defun shen.findallhelp (V2945 V2946 V2947 V2948 V2949 V2950) (let Case (do (shen.incinfs) (call V2946 V2949 (freeze (shen.remember V2948 V2945 V2949 (freeze (fwhen false V2949 V2950)))))) (if (= Case false) (do (shen.incinfs) (bind V2947 (value (shen.lazyderef V2948 V2949)) V2949 V2950)) Case)))

(defun shen.remember (V2951 V2952 V2953 V2954) (let B (shen.newpv V2953) (do (shen.incinfs) (bind B (set (shen.deref V2951 V2953) (cons (shen.deref V2952 V2953) (value (shen.deref V2951 V2953)))) V2953 V2954))))

(defun shen.t*-defcc (V2955 V2956 V2957 V2958 V2959) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2425 (shen.lazyderef V2955 V2958) (if (cons? V2425) (let V2426 (shen.lazyderef (hd V2425) V2958) (if (= defcc V2426) (let V2427 (shen.lazyderef (tl V2425) V2958) (if (cons? V2427) (let F (hd V2427) (let V2428 (shen.lazyderef (tl V2427) V2958) (if (cons? V2428) (let V2429 (shen.lazyderef (hd V2428) V2958) (if (= { V2429) (let V2430 (shen.lazyderef (tl V2428) V2958) (if (cons? V2430) (let V2431 (shen.lazyderef (hd V2430) V2958) (if (cons? V2431) (let V2432 (shen.lazyderef (hd V2431) V2958) (if (= list V2432) (let V2433 (shen.lazyderef (tl V2431) V2958) (if (cons? V2433) (let A (hd V2433) (let V2434 (shen.lazyderef (tl V2433) V2958) (if (= () V2434) (let V2435 (shen.lazyderef (tl V2430) V2958) (if (cons? V2435) (let V2436 (shen.lazyderef (hd V2435) V2958) (if (= ==> V2436) (let V2437 (shen.lazyderef (tl V2435) V2958) (if (cons? V2437) (let B (hd V2437) (let V2438 (shen.lazyderef (tl V2437) V2958) (if (cons? V2438) (let V2439 (shen.lazyderef (hd V2438) V2958) (if (= } V2439) (let Rest (tl V2438) (let Rest& (shen.newpv V2958) (let Rest&& (shen.newpv V2958) (let Rules (shen.newpv V2958) (let ListA&& (shen.newpv V2958) (let B&& (shen.newpv V2958) (let Sig (shen.newpv V2958) (let Declare (shen.newpv V2958) (do (shen.incinfs) (bind Sig (shen.placeholders (cons (cons list (cons (shen.lazyderef A V2958) ())) (cons ==> (cons (shen.lazyderef B V2958) ()))) (shen.extract_vars (cons (cons list (cons (shen.lazyderef A V2958) ())) (cons ==> (cons (shen.lazyderef B V2958) ()))))) V2958 (freeze (bind ListA&& (hd (shen.lazyderef Sig V2958)) V2958 (freeze (bind B&& (hd (tl (tl (shen.lazyderef Sig V2958)))) V2958 (freeze (bind Rest& (shen.plug-wildcards (shen.lazyderef Rest V2958)) V2958 (freeze (bind Rest&& (shen.placeholders (shen.lazyderef Rest& V2958) (shen.extract_vars (shen.lazyderef Rest& V2958))) V2958 (freeze (shen.get-rules Rules Rest&& V2958 (freeze (cut Throwcontrol V2958 (freeze (shen.tc-rules F Rules ListA&& B&& (cons (cons F (cons : (cons Sig ()))) V2957) 1 V2958 (freeze (unify V2956 (cons (cons list (cons A ())) (cons ==> (cons B ()))) V2958 (freeze (bind Declare (declare (shen.lazyderef F V2958) (cons (cons list (cons (shen.lazyderef A V2958) ())) (cons ==> (cons (shen.lazyderef B V2958) ())))) V2958 V2959)))))))))))))))))))))))))))) false)) false))) false)) false)) false)) false))) false)) false)) false)) false)) false)) false))) false)) false)) false)))))

(defun shen.plug-wildcards (V2960) (cond ((cons? V2960) (map shen.plug-wildcards V2960)) ((= V2960 _) (gensym (intern "X"))) (true V2960)))

(defun shen.get-rules (V2961 V2962 V2963 V2964) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2418 (shen.lazyderef V2961 V2963) (if (= () V2418) (let V2419 (shen.lazyderef V2962 V2963) (if (= () V2419) (do (shen.incinfs) (cut Throwcontrol V2963 V2964)) false)) (if (shen.pvar? V2418) (do (shen.bindv V2418 () V2963) (let Result (let V2420 (shen.lazyderef V2962 V2963) (if (= () V2420) (do (shen.incinfs) (cut Throwcontrol V2963 V2964)) false)) (do (shen.unbindv V2418 V2963) Result))) false))) (if (= Case false) (let V2421 (shen.lazyderef V2961 V2963) (if (cons? V2421) (let Rule (hd V2421) (let Rules (tl V2421) (let Other (shen.newpv V2963) (do (shen.incinfs) (shen.first-rule V2962 Rule Other V2963 (freeze (cut Throwcontrol V2963 (freeze (shen.get-rules Rules Other V2963 V2964))))))))) (if (shen.pvar? V2421) (let Rule (shen.newpv V2963) (let Rules (shen.newpv V2963) (do (shen.bindv V2421 (cons Rule Rules) V2963) (let Result (let Other (shen.newpv V2963) (do (shen.incinfs) (shen.first-rule V2962 Rule Other V2963 (freeze (cut Throwcontrol V2963 (freeze (shen.get-rules Rules Other V2963 V2964))))))) (do (shen.unbindv V2421 V2963) Result))))) false))) Case)))))

(defun shen.first-rule (V2965 V2966 V2967 V2968 V2969) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2411 (shen.lazyderef V2965 V2968) (if (cons? V2411) (let V2412 (shen.lazyderef (hd V2411) V2968) (if (= ; V2412) (let Other2406 (tl V2411) (let V2413 (shen.lazyderef V2966 V2968) (if (= () V2413) (do (shen.incinfs) (unify! V2967 Other2406 V2968 (freeze (cut Throwcontrol V2968 V2969)))) (if (shen.pvar? V2413) (do (shen.bindv V2413 () V2968) (let Result (do (shen.incinfs) (unify! V2967 Other2406 V2968 (freeze (cut Throwcontrol V2968 V2969)))) (do (shen.unbindv V2413 V2968) Result))) false)))) false)) false)) (if (= Case false) (let V2414 (shen.lazyderef V2965 V2968) (if (cons? V2414) (let X2407 (hd V2414) (let Rest (tl V2414) (let V2415 (shen.lazyderef V2966 V2968) (if (cons? V2415) (let X (hd V2415) (let Rule (tl V2415) (do (shen.incinfs) (unify! X X2407 V2968 (freeze (shen.first-rule Rest Rule V2967 V2968 V2969)))))) (if (shen.pvar? V2415) (let X (shen.newpv V2968) (let Rule (shen.newpv V2968) (do (shen.bindv V2415 (cons X Rule) V2968) (let Result (do (shen.incinfs) (unify! X X2407 V2968 (freeze (shen.first-rule Rest Rule V2967 V2968 V2969)))) (do (shen.unbindv V2415 V2968) Result))))) false))))) false)) Case)))))

(defun shen.tc-rules (V2970 V2971 V2972 V2973 V2974 V2975 V2976 V2977) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2400 (shen.lazyderef V2971 V2976) (if (= () V2400) (do (shen.incinfs) (thaw V2977)) false)) (if (= Case false) (let V2401 (shen.lazyderef V2971 V2976) (if (cons? V2401) (let Rule (hd V2401) (let Rules (tl V2401) (let V2402 (shen.lazyderef V2972 V2976) (if (cons? V2402) (let V2403 (shen.lazyderef (hd V2402) V2976) (if (= list V2403) (let V2404 (shen.lazyderef (tl V2402) V2976) (if (cons? V2404) (let A (hd V2404) (let V2405 (shen.lazyderef (tl V2404) V2976) (if (= () V2405) (let M (shen.newpv V2976) (do (shen.incinfs) (shen.tc-rule V2970 Rule A V2973 V2974 V2975 V2976 (freeze (bind M (+ (shen.deref V2975 V2976) 1) V2976 (freeze (cut Throwcontrol V2976 (freeze (shen.tc-rules V2970 Rules (cons list (cons A ())) V2973 V2974 M V2976 V2977))))))))) false))) false)) false)) false)))) false)) Case)))))

(defun shen.tc-rule (V2978 V2979 V2980 V2981 V2982 V2983 V2984 V2985) (let Case (do (shen.incinfs) (shen.check-defcc-rule V2979 V2980 V2981 V2982 V2984 V2985)) (if (= Case false) (let Err (shen.newpv V2984) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2983 V2984) (cn " of " (shen.app (shen.lazyderef V2978 V2984) "" shen.a)) shen.a))) V2984 V2985))) Case)))

(defun shen.check-defcc-rule (V2986 V2987 V2988 V2989 V2990 V2991) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Syntax (shen.newpv V2990) (let Semantics (shen.newpv V2990) (let SynHyps (shen.newpv V2990) (do (shen.incinfs) (shen.get-syntax+semantics Syntax Semantics V2986 V2990 (freeze (cut Throwcontrol V2990 (freeze (shen.syntax-hyps Syntax V2989 SynHyps V2987 V2990 (freeze (cut Throwcontrol V2990 (freeze (shen.syntax-check Syntax V2987 SynHyps V2990 (freeze (cut Throwcontrol V2990 (freeze (shen.semantics-check Semantics V2988 SynHyps V2990 V2991))))))))))))))))))))

(defun shen.syntax-hyps (V2992 V2993 V2994 V2995 V2996 V2997) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2371 (shen.lazyderef V2992 V2996) (if (= () V2371) (do (shen.incinfs) (unify! V2994 V2993 V2996 V2997)) false)) (if (= Case false) (let Case (let V2372 (shen.lazyderef V2992 V2996) (if (cons? V2372) (let V2373 (shen.lazyderef (hd V2372) V2996) (if (cons? V2373) (let X (hd V2373) (let Y (tl V2373) (let Z (tl V2372) (let W (shen.newpv V2996) (do (shen.incinfs) (cut Throwcontrol V2996 (freeze (shen.conc (cons X Y) Z W V2996 (freeze (cut Throwcontrol V2996 (freeze (shen.syntax-hyps W V2993 V2994 V2995 V2996 V2997)))))))))))) false)) false)) (if (= Case false) (let Case (let V2374 (shen.lazyderef V2992 V2996) (if (cons? V2374) (let X2365 (hd V2374) (let Y (tl V2374) (let V2375 (shen.lazyderef V2994 V2996) (if (cons? V2375) (let V2376 (shen.lazyderef (hd V2375) V2996) (if (cons? V2376) (let X (hd V2376) (let V2377 (shen.lazyderef (tl V2376) V2996) (if (cons? V2377) (let V2378 (shen.lazyderef (hd V2377) V2996) (if (= : V2378) (let V2379 (shen.lazyderef (tl V2377) V2996) (if (cons? V2379) (let A2366 (hd V2379) (let V2380 (shen.lazyderef (tl V2379) V2996) (if (= () V2380) (let SynHyps (tl V2375) (do (shen.incinfs) (unify! V2995 A2366 V2996 (freeze (unify! X X2365 V2996 (freeze (fwhen (shen.placeholder? (shen.deref X V2996)) V2996 (freeze (cut Throwcontrol V2996 (freeze (shen.syntax-hyps Y V2993 SynHyps V2995 V2996 V2997))))))))))) (if (shen.pvar? V2380) (do (shen.bindv V2380 () V2996) (let Result (let SynHyps (tl V2375) (do (shen.incinfs) (unify! V2995 A2366 V2996 (freeze (unify! X X2365 V2996 (freeze (fwhen (shen.placeholder? (shen.deref X V2996)) V2996 (freeze (cut Throwcontrol V2996 (freeze (shen.syntax-hyps Y V2993 SynHyps V2995 V2996 V2997))))))))))) (do (shen.unbindv V2380 V2996) Result))) false)))) (if (shen.pvar? V2379) (let A2366 (shen.newpv V2996) (do (shen.bindv V2379 (cons A2366 ()) V2996) (let Result (let SynHyps (tl V2375) (do (shen.incinfs) (unify! V2995 A2366 V2996 (freeze (unify! X X2365 V2996 (freeze (fwhen (shen.placeholder? (shen.deref X V2996)) V2996 (freeze (cut Throwcontrol V2996 (freeze (shen.syntax-hyps Y V2993 SynHyps V2995 V2996 V2997))))))))))) (do (shen.unbindv V2379 V2996) Result)))) false))) (if (shen.pvar? V2378) (do (shen.bindv V2378 : V2996) (let Result (let V2381 (shen.lazyderef (tl V2377) V2996) (if (cons? V2381) (let A2366 (hd V2381) (let V2382 (shen.lazyderef (tl V2381) V2996) (if (= () V2382) (let SynHyps (tl V2375) (do (shen.incinfs) (unify! V2995 A2366 V2996 (freeze (unify! X X2365 V2996 (freeze (fwhen (shen.placeholder? (shen.deref X V2996)) V2996 (freeze (cut Throwcontrol V2996 (freeze (shen.syntax-hyps Y V2993 SynHyps V2995 V2996 V2997))))))))))) (if (shen.pvar? V2382) (do (shen.bindv V2382 () V2996) (let Result (let SynHyps (tl V2375) (do (shen.incinfs) (unify! V2995 A2366 V2996 (freeze (unify! X X2365 V2996 (freeze (fwhen (shen.placeholder? (shen.deref X V2996)) V2996 (freeze (cut Throwcontrol V2996 (freeze (shen.syntax-hyps Y V2993 SynHyps V2995 V2996 V2997))))))))))) (do (shen.unbindv V2382 V2996) Result))) false)))) (if (shen.pvar? V2381) (let A2366 (shen.newpv V2996) (do (shen.bindv V2381 (cons A2366 ()) V2996) (let Result (let SynHyps (tl V2375) (do (shen.incinfs) (unify! V2995 A2366 V2996 (freeze (unify! X X2365 V2996 (freeze (fwhen (shen.placeholder? (shen.deref X V2996)) V2996 (freeze (cut Throwcontrol V2996 (freeze (shen.syntax-hyps Y V2993 SynHyps V2995 V2996 V2997))))))))))) (do (shen.unbindv V2381 V2996) Result)))) false))) (do (shen.unbindv V2378 V2996) Result))) false))) (if (shen.pvar? V2377) (let A2366 (shen.newpv V2996) (do (shen.bindv V2377 (cons : (cons A2366 ())) V2996) (let Result (let SynHyps (tl V2375) (do (shen.incinfs) (unify! V2995 A2366 V2996 (freeze (unify! X X2365 V2996 (freeze (fwhen (shen.placeholder? (shen.deref X V2996)) V2996 (freeze (cut Throwcontrol V2996 (freeze (shen.syntax-hyps Y V2993 SynHyps V2995 V2996 V2997))))))))))) (do (shen.unbindv V2377 V2996) Result)))) false)))) (if (shen.pvar? V2376) (let X (shen.newpv V2996) (let A2366 (shen.newpv V2996) (do (shen.bindv V2376 (cons X (cons : (cons A2366 ()))) V2996) (let Result (let SynHyps (tl V2375) (do (shen.incinfs) (unify! V2995 A2366 V2996 (freeze (unify! X X2365 V2996 (freeze (fwhen (shen.placeholder? (shen.deref X V2996)) V2996 (freeze (cut Throwcontrol V2996 (freeze (shen.syntax-hyps Y V2993 SynHyps V2995 V2996 V2997))))))))))) (do (shen.unbindv V2376 V2996) Result))))) false))) (if (shen.pvar? V2375) (let X (shen.newpv V2996) (let A2366 (shen.newpv V2996) (let SynHyps (shen.newpv V2996) (do (shen.bindv V2375 (cons (cons X (cons : (cons A2366 ()))) SynHyps) V2996) (let Result (do (shen.incinfs) (unify! V2995 A2366 V2996 (freeze (unify! X X2365 V2996 (freeze (fwhen (shen.placeholder? (shen.deref X V2996)) V2996 (freeze (cut Throwcontrol V2996 (freeze (shen.syntax-hyps Y V2993 SynHyps V2995 V2996 V2997)))))))))) (do (shen.unbindv V2375 V2996) Result)))))) false))))) false)) (if (= Case false) (let V2383 (shen.lazyderef V2992 V2996) (if (cons? V2383) (let Y (tl V2383) (do (shen.incinfs) (shen.syntax-hyps Y V2993 V2994 V2995 V2996 V2997))) false)) Case)) Case)) Case)))))

(defun shen.get-syntax+semantics (V2998 V2999 V3000 V3001 V3002) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2337 (shen.lazyderef V2998 V3001) (if (= () V2337) (let V2338 (shen.lazyderef V3000 V3001) (if (cons? V2338) (let V2339 (shen.lazyderef (hd V2338) V3001) (if (= := V2339) (let V2340 (shen.lazyderef (tl V2338) V3001) (if (cons? V2340) (let Semantics (hd V2340) (let V2341 (shen.lazyderef (tl V2340) V3001) (if (= () V2341) (do (shen.incinfs) (cut Throwcontrol V3001 (freeze (bind V2999 (shen.lazyderef Semantics V3001) V3001 V3002)))) false))) false)) false)) false)) (if (shen.pvar? V2337) (do (shen.bindv V2337 () V3001) (let Result (let V2342 (shen.lazyderef V3000 V3001) (if (cons? V2342) (let V2343 (shen.lazyderef (hd V2342) V3001) (if (= := V2343) (let V2344 (shen.lazyderef (tl V2342) V3001) (if (cons? V2344) (let Semantics (hd V2344) (let V2345 (shen.lazyderef (tl V2344) V3001) (if (= () V2345) (do (shen.incinfs) (cut Throwcontrol V3001 (freeze (bind V2999 (shen.lazyderef Semantics V3001) V3001 V3002)))) false))) false)) false)) false)) (do (shen.unbindv V2337 V3001) Result))) false))) (if (= Case false) (let Case (let V2346 (shen.lazyderef V2998 V3001) (if (= () V2346) (let V2347 (shen.lazyderef V3000 V3001) (if (cons? V2347) (let V2348 (shen.lazyderef (hd V2347) V3001) (if (= := V2348) (let V2349 (shen.lazyderef (tl V2347) V3001) (if (cons? V2349) (let Semantics (hd V2349) (let V2350 (shen.lazyderef (tl V2349) V3001) (if (cons? V2350) (let V2351 (shen.lazyderef (hd V2350) V3001) (if (= where V2351) (let V2352 (shen.lazyderef (tl V2350) V3001) (if (cons? V2352) (let G (hd V2352) (let V2353 (shen.lazyderef (tl V2352) V3001) (if (= () V2353) (do (shen.incinfs) (cut Throwcontrol V3001 (freeze (bind V2999 (cons where (cons (shen.lazyderef G V3001) (cons (shen.lazyderef Semantics V3001) ()))) V3001 V3002)))) false))) false)) false)) false))) false)) false)) false)) (if (shen.pvar? V2346) (do (shen.bindv V2346 () V3001) (let Result (let V2354 (shen.lazyderef V3000 V3001) (if (cons? V2354) (let V2355 (shen.lazyderef (hd V2354) V3001) (if (= := V2355) (let V2356 (shen.lazyderef (tl V2354) V3001) (if (cons? V2356) (let Semantics (hd V2356) (let V2357 (shen.lazyderef (tl V2356) V3001) (if (cons? V2357) (let V2358 (shen.lazyderef (hd V2357) V3001) (if (= where V2358) (let V2359 (shen.lazyderef (tl V2357) V3001) (if (cons? V2359) (let G (hd V2359) (let V2360 (shen.lazyderef (tl V2359) V3001) (if (= () V2360) (do (shen.incinfs) (cut Throwcontrol V3001 (freeze (bind V2999 (cons where (cons (shen.lazyderef G V3001) (cons (shen.lazyderef Semantics V3001) ()))) V3001 V3002)))) false))) false)) false)) false))) false)) false)) false)) (do (shen.unbindv V2346 V3001) Result))) false))) (if (= Case false) (let V2361 (shen.lazyderef V2998 V3001) (if (cons? V2361) (let X2333 (hd V2361) (let Syntax (tl V2361) (let V2362 (shen.lazyderef V3000 V3001) (if (cons? V2362) (let X (hd V2362) (let Rule (tl V2362) (do (shen.incinfs) (unify! X X2333 V3001 (freeze (shen.get-syntax+semantics Syntax V2999 Rule V3001 V3002)))))) false)))) (if (shen.pvar? V2361) (let X2333 (shen.newpv V3001) (let Syntax (shen.newpv V3001) (do (shen.bindv V2361 (cons X2333 Syntax) V3001) (let Result (let V2363 (shen.lazyderef V3000 V3001) (if (cons? V2363) (let X (hd V2363) (let Rule (tl V2363) (do (shen.incinfs) (unify! X X2333 V3001 (freeze (shen.get-syntax+semantics Syntax V2999 Rule V3001 V3002)))))) false)) (do (shen.unbindv V2361 V3001) Result))))) false))) Case)) Case)))))

(defun shen.syntax-check (V3003 V3004 V3005 V3006 V3007) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2330 (shen.lazyderef V3003 V3006) (if (= () V2330) (do (shen.incinfs) (thaw V3007)) false)) (if (= Case false) (let Case (let V2331 (shen.lazyderef V3003 V3006) (if (cons? V2331) (let X (hd V2331) (let Syntax (tl V2331) (let C (shen.newpv V3006) (let X&& (shen.newpv V3006) (let B (shen.newpv V3006) (do (shen.incinfs) (fwhen (shen.grammar_symbol? (shen.lazyderef X V3006)) V3006 (freeze (cut Throwcontrol V3006 (freeze (shen.t* (cons X (cons : (cons (cons (cons list (cons B ())) (cons ==> (cons C ()))) ()))) V3005 V3006 (freeze (cut Throwcontrol V3006 (freeze (bind X&& (concat && (shen.lazyderef X V3006)) V3006 (freeze (cut Throwcontrol V3006 (freeze (shen.t* (cons X&& (cons : (cons (cons list (cons V3004 ())) ()))) (cons (cons X&& (cons : (cons (cons list (cons B ())) ()))) V3005) V3006 (freeze (cut Throwcontrol V3006 (freeze (shen.syntax-check Syntax V3004 V3005 V3006 V3007))))))))))))))))))))))) false)) (if (= Case false) (let V2332 (shen.lazyderef V3003 V3006) (if (cons? V2332) (let X (hd V2332) (let Syntax (tl V2332) (do (shen.incinfs) (shen.t* (cons X (cons : (cons V3004 ()))) V3005 V3006 (freeze (cut Throwcontrol V3006 (freeze (shen.syntax-check Syntax V3004 V3005 V3006 V3007)))))))) false)) Case)) Case)))))

(defun shen.semantics-check (V3008 V3009 V3010 V3011 V3012) (let Semantics* (shen.newpv V3011) (do (shen.incinfs) (bind Semantics* (shen.curry (shen.rename-semantics (shen.deref V3008 V3011))) V3011 (freeze (shen.t* (cons Semantics* (cons : (cons V3009 ()))) V3010 V3011 V3012))))))

(defun shen.rename-semantics (V3013) (cond ((cons? V3013) (cons (shen.rename-semantics (hd V3013)) (shen.rename-semantics (tl V3013)))) ((shen.grammar_symbol? V3013) (cons shen.<-sem (cons V3013 ()))) (true V3013)))



